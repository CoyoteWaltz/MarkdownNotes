# Reading List

[toc]

> ~~这一块内容的排版想自己重新设计一下，太丑了，也不方便~~

> 阅读记录，材料不限于文字、视频、音频。
>
> 怎么感觉在做和马老师[一样的事情](https://thinking.tomotoes.com/)
>
> 链接/Notion 爬下来的 md + 摘要
>
> Dont Highlight, Do Summary!
>
> 用于信息收集，还未到学习阶段～真的用到再学！

> TODO:
>
> - [ ] 文章类型分类 or Tag
> - [ ] 定期整理！

## Viewed

**2021.01.09 13:42:18**

### 【理财】

[实现财务自由](https://www.zhihu.com/question/265675232/answer/1648647115)

> 控制消费欲望、尽快建立人生第二收入、把工作当作一种投资、不断提升认知

[beyond 4 percent rule](https://www.schwab.com/resource-center/insights/content/beyond-4-rule-how-much-can-you-safely-spend-retirement)

> 依旧是从阮一峰的书中[这篇文章](https://survivor.ruanyifeng.com/plan-b/retire.html)看到的概念，于是就去 google 了一下
>
> 4% 规则：
>
> - 衡量退休之后你的资产够不够用
> - 按照你每年消耗的资金作为总资产的 4% 来看，你的资产能支撑多少年？
>
> 这篇文章也反问了一些问题：退休后的年数？如何投资？支出是否稳定？
>
> 以及给出了一些建议，说实话感觉对我现在没啥用，先不记了

[银行转账发生了什么](https://gendal.me/2013/11/24/a-simple-explanation-of-how-money-moves-around-the-banking-system/)

> 13 年的文章了，由浅入深的介绍了一次转账/付款在银行内部/之间发生了怎么样的过程。
>
> 转账的本质：钱从某一账户流入另一个账户。
>
> 从同一个银行的两个账户，到不同银行之间，复杂度提升，存在的问题（counterparty risk, liquidity, cost），引入 **correspondent banking**，SWIFT，到最后的 central bank（**Real-Time Gross Settlement**）来解决上面这些流动性等问题。
>
> - **correspondent banking**：两个银行之间互相拥有对方的账户
> - [SWIFT](https://en.wikipedia.org/wiki/SWIFT)：银行金融通信。（安全）用 message 通知另一个银行操作，好比发消息。
> - RTGS：central bank 管理所有的账户，其中的 Gross 表示直接账户操作，没有网络关系，有好的实时性，Settlement
>
> 其实最后自己有个问题：所以在商业银行开的账户，其实也是在央行开的账户，在商业银行绑定了一子账户 or 继承？

---

### 【职业】

[前端升级之路](https://www.zhihu.com/question/55058833/answer/1640978174)

> 业务视角看前端，比较现实，挺有启发

[别让自己"墙"了自己 | | 酷 壳 - CoolShell](Reading%20List%2068c05d9b17b04eac936dcb715058a8ab/%E5%88%AB%E8%AE%A9%E8%87%AA%E5%B7%B1%20%E5%A2%99%20%E4%BA%86%E8%87%AA%E5%B7%B1%20%E9%85%B7%20%E5%A3%B3%20-%20CoolShell%20ea1728ca42464b43b5a16794b5f3840f.md)

> 好文，建议所有人阅读

[程序员如何把控自己的职业 | | 酷 壳 - CoolShell](Reading%20List%2068c05d9b17b04eac936dcb715058a8ab/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E6%8A%8A%E6%8E%A7%E8%87%AA%E5%B7%B1%E7%9A%84%E8%81%8C%E4%B8%9A%20%E9%85%B7%20%E5%A3%B3%20-%20CoolShell%20c57bacbff6c341fa903a68f441fc9df8.md)

> 好文，值得反复阅读

[加班与效率 | 酷 壳 - CoolShell](Reading%20List%2068c05d9b17b04eac936dcb715058a8ab/%E5%8A%A0%E7%8F%AD%E4%B8%8E%E6%95%88%E7%8E%87%20%E9%85%B7%20%E5%A3%B3%20-%20CoolShell%20d465aed6fede4c488eb89dd1030107d1.md)

> 效率的衡量方式

[《Rework》摘录及感想 | 酷 壳 - CoolShell](Reading%20List%2068c05d9b17b04eac936dcb715058a8ab/%E3%80%8ARework%E3%80%8B%E6%91%98%E5%BD%95%E5%8F%8A%E6%84%9F%E6%83%B3%20%E9%85%B7%20%E5%A3%B3%20-%20CoolShell%201f280c82fbcc49308254b6368be4f36b.md)

[一个产品需求的研发流程是怎样的](https://mp.weixin.qq.com/s/ujfZBl9HR_0_FCr1Zz-SVQ)

> 快餐文分享，写的比较全了，符合大厂情况，适合职场新人看

[演进：如何用练习快速提升技术](https://mp.weixin.qq.com/s/L-pgJsxw442xxdaOYJGz-A)

> SMART 法则：
>
> - **具体的（Specific）即我们要有一个明确的**目标，如在一周内用 Django 写一个博客系统，而不是用 Django 写个东西。
> - 可度量的（Measurable）即衡量是否达成目标，我们只需要能创建、查看、删除博客，那么我们就算完成了这样的任务。它可以用来不断地突破自己。
> - 可实现性（Attainable）即这个目标一定是可以实现的，不能实现的目标没有啥意义。与些同时，练习初期定下的目标不能困难。
> - 相关性（Relevant）即目标与其他目标的关联情况，如我们练习 Django 是为了提高 Django 或者后台的技能。如果我们的大目标是提高前端技能，那么这个目标对于当前的意义并不是太大。
> - 时限（Time-based）即时间限制，如上面提到的一周内用 Django 写一个博客系统的期限。

【好文】[时代](https://mp.weixin.qq.com/s/NdNv3LiO_3IxrgyeG5Xubw)

> 很宏大的角度从负利率的国债去看当今中国和欧洲/日本社会的发展情况
>
> 最终消费的动力主要来自三点：
> 1、孩子；2、年轻的女人；3、技术的更新迭代。
>
> 现在互联网技术风口耗尽了，整体格局也差不多了。现在互联网大厂连菜贩子的生意都抢，大部分行业跟餐饮业一样，一片红海。
>
> 那整个社会佛系了它不好吗？没这么简单了。比如作为富豪阶层却有大量的钱投资不出去，放手里通货膨胀贬值，存银行也不赚钱，最后想来想去，只好去追那些少数优质资产，最后把那些资产给追到天上去了。
>
> “每一个人自由发展是一切人自由发展的条件”，给每个人发展的机会，才是最大的福利。
>
> 富人通胀，穷人通缩。

【好文】[前端职业思考](https://github.com/ascoders/weekly/blob/master/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/196.%E7%B2%BE%E8%AF%BB%E3%80%8A%E5%89%8D%E7%AB%AF%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92%20-%202021%20%E5%B9%B4%E3%80%8B.md)

> 职业方向思考
>
> - 前端出现的原因：前端只是用户与业务系统交互的窗口，为了降低用户的使用成本而出现的。
> - ”所以公司是一个相对大锅饭的组织，谁也不要给自己工作定价，大家都尽可能的打磨产品，月底按照合同约定给固定薪酬。这样做确实解决了产品长期发展的问题，但这套机制成熟后，尤其在大公司，刚毕业就去拧螺丝钉的同学很可能永远没有机会了解何为成本，没有成本概念，就难以想清楚为什么做事要考虑投入产出比，或者觉得 ROI 这个词很高级，其实这个词一点不高级，只是公司将它屏蔽了，但如果这导致你做技术完全不考虑成本，只追求让你激动的技术细节，或者只做你感兴趣的技术方向，那其实是不成熟的表现，你做的事情可能也难以被业务认可。“
>
> 文章来自 github [前端精选周刊](https://github.com/ascoders/weekly/issues?q=is%3Aissue+is%3Aclosed) 看 issue 更新

2022.05.01 14:39:01

[欧洲求职经历](https://ludoro.github.io/blog/career/2022/02/14/newgrad.html)

> 是从阮一峰 weekly（Y22W18）看到的，作者是在欧洲毕业的博士生（应用数学背景、目标 ML 工程师）
>
> 他在文章中讲述了自己的背景、面试的经历、和收到的一些 offer。从中能得到一些启发：
>
> - 找新工作的时候，需要准备的东西（国外很注重刷题和技术）
> - 新工作决定了很多，需要权衡更多（地区、收入、环境、氛围、甚至是税收）
> - 以及发现了一个网站：https://www.levels.fyi/，海外公司的薪资介绍

[Basecamp 的经验](https://catcoding.me/p/weekly-3/), [youtube](https://www.youtube.com/watch?v=wC14JM94BIs)

> Basecamp 是一直马了但还没读的《Rework》的作者的公司，youtube 的演讲分享了几个点，对于做一家公司/产品的一些建议，很不错。具体内容文章也有概述，视频值得反复观看
>
> 一些有共鸣的点：
>
> - 方言（dialect）：产品和用户之间，产品和平台之间，各个角色之间是存在方言（信息差）的，如何去理解、尝试用不同的方言去和各方沟通？

[做 tech leader 的 42 条经验](https://maheshba.bitbucket.io/blog/2021/10/19/42Things.html)

> 一些团队管理、设计、code review 的经验，马了以后再读！

[the fg command](https://lambdaisland.com/blog/2022-02-17-the-fg-command)

> `fg` 是 linux 的一个指令（foreground），将一个后台进程移动到你的前台 shell 中，作者用这个指令来比喻潜意识 -> 意识层面的过程，得以快速醒悟一些不好的潜意识习惯。
>
> 作者编程十年逐渐发现自己更多的是 typing 而缺少了 thinking，typing 更多的会形成一种肌肉记忆，而导致缺少 analytic thinking。一些方法：
>
> - 将自己的代码逻辑解释给他人
> - 问自己一些已有的问题
>   - 遇到 bug
>   - 写函数
>     - **contingent designs** for errors like `try/catch` and logs?
>     - **preventive designs** for errors like `pre` condition or `assert`?
>     - Should the function name describe **the purpose**?
>     - Do I add some suitable doc strings on functions?
>   - 写模块
>     - api 声明
>     - 删除无用代码
>     - ...
>   - 集成/开发
>     - 有没有写单测
>     - 自动化脚本
>     - feedback messages？

[规划三阶段](https://zhuanlan.zhihu.com/p/554292991)

> 一技之长
>
> - 深入栈内技术
> - 学习栈外技术（T 字型人才）
> - 工程能力
> - 带人做事（管人和带人的区别：管人是知道我不懂的领域他会，安排他做；带人是我懂这个领域，他不懂，我教他做的更好。学会提问，才能让人成长）
> - 业内影响力
>
> 独立做事
>
> - 独立交付
> - 独立带人
> - 独立做任务/生存
>
> 寻找使命
>
> - 实现自我价值～诗和远方

[Engineer/Manager pendulum](https://charity.wtf/2022/03/24/twin-anxieties-of-the-engineer-manager-pendulum/)

> 文章讲了当一个 manager 回到 engineer 身份可能会存在的一些焦虑：
>
> - 是否会失去之后当 manager 的资格？
> - 作为一线开发者会变得 rusty
>
> 以及对于这些焦虑的一些对策（鸡汤）：
>
> - manager 能力（软技能）能在各个工作环节起到帮助作用，知道排序优先级、如何推进、如何沟通、提出建议...并且这些能力不会过期（对比技术来说）
> - 技术需要不断翻新，keeping your hands-on skills sharp，做 manager 也起码是 senior 开发者。
> - 爬得越高（职位）机会越少
>
> 摘录最后一句话，保持时刻学习和回顾！Maintaining your technical chops is a stellar way to hedge against uncertainties and maintain your optionality.

[在工作中学习](https://plantegg.github.io/2018/05/23/%E5%A6%82%E4%BD%95%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%AD%A6%E4%B9%A0/)

> 工作效率
>
> 知识效率
>
> 好好学习底层的知识！

2023.04.04 20:51:42 +0800

[前端已死？](https://www.zhangxinxu.com/life/2023/03/fe-dead/)

> _提高个人的核心竞争力。_
>
> - 比他人涉猎更广，例如音视频处理、图形表现实现或者 Node 开发有较多经验；
> - JS、CSS 等前端**基本功扎实**，积累深厚，各种 API 特性了然于心，最佳实践信手捏来；
> - 具有设计审美或者产品嗅觉灵敏，开发的产品体验非常好，干活很细。（**踏实靠谱，脚踏实地干活**）
>
> 给自己打打鸡血吧哈哈

---

### 【个人】

2021.02.13 20:40:25

【好文】[信息方法论](https://blog.ddlee.cc/posts/3a6233e2/)

> - 信息模型：信息+信息所依托的形式—>渠道—>接收者—>对接收者产生影响
> - 我所理解的信息处理实践的框架，有三个关键的维度：信息类型、时间质量和处理状态。于是，信息处理的问题可以表述为：**如何以合理的时间和精力投入，使不同类型的信息达到适合的处理状态？**
> - 并不是每一分钟都有同样的质量
> - 文字太模糊了，不足以让你记起全部的细节，你只好亲自走回去，回到青葱的岁月，像看故事里的人物那样看看那时的自己；文字又太准确了，这些陌生又熟悉的字眼，这些亲切又早已忘却的句子，就像当年的自己把故事亲口哼唱给你听，此时此刻，恰如彼时彼刻。文字脆弱，却又力量无穷。
> - RSS Rich Site Summary

[什么是 RSS](https://blog.ddlee.cc/posts/5768c6d/)

> 信息源头 -> 阅读者
>
> 信息源头 -> 平台 -> 阅读者（数量增多）
>
> 信息源头 -> 平台（过滤，推荐，隐藏） -> 阅读者（数量增多）
>
> RSS：
>
> - Rich Site Summary & Really Simple Syndication（前者注重格式，后者强调目的：方便更新）
> - 一种信息流动的格式/协议：「允许内容提供者按一定格式组织和发布内容，方便内容消费者抓取。你甚至可以认为，它是一项信息提供者和消费者之间的“契约”。」
>
> 如何使用 RSS：
>
> 1. 找到网站（我主要以大佬们的博客为主）的 RSS 链接
> 2. 去 [Feedly](https://feedly.com/) 服务，创建账号，搜索 RSS 订阅（想用 mac 的客户端 reeder 发现要 A 区账号而且还要钱。。）
> 3. 手机也可以下载 Feedly（需要 A 区账号）
>
> TODO 一些 RSS 源：
>
> - https://www.zhihu.com/question/19580096

2021.03.04 22:44:37

[the paradox of abundance](https://perell.com/note/the-paradox-of-abundance/)

> 讲了目前信息爆炸的现状
>
> 摘录几句话：
>
> Average consumers are doomed to the tyranny of instinct. Meanwhile, consumers at the top are propelled by unlimited access to nutritious food and information.
>
> On the Internet, your rate of learning is limited not by access to information, but by your ability to ignore distractions.

2021.03.07 18:33:58

[Solo-year-1](https://mtlynch.io/solo-developer-year-1/), [why left Google](https://mtlynch.io/why-i-quit-google/)

> 读了网上一位前 google 的大佬员工的经历，从工作到创业，感触颇多。最后作者离开了谷歌
>
> 摘录几个点：
>
> - Limit focus，作者原以为自由创业之后会有更多的时间和精力，现实缺恰恰相反
> - Regularly reflection，我也有这样的习惯，不过最近执行的很糟。。
> - Set goals，measurable goals，我觉得 OKR 会更好吧，目前我这快比较差。。
>
> 工作上的晋升建议（作者在 google 晋升之路坎坷的不行）
>
> - 量化的记录（qualifiable record）

[为什么可以不读大学--阮一峰](https://survivor.ruanyifeng.com/collapse/university.html)（1）

[东亚教育浪费了太多生命](https://www.jiemian.com/article/887630.html)（2）

> （2）亚洲教育的对比，思考和感触很多，也很庆幸自己在 K-12 的教育制度中没有失去想象力和个性吧
>
> 内容还是比较深刻和辽阔的
>
> - 普鲁士基因
> - 复习的过度重视，孔子当年学的是“礼”，是需要不断重复演练，如今我们学的是”认知“
> - 联考 - 平均主义 - 一刀压制了不同类型的人才
> - 好学生一定得做到：要自我决定学习的侧重，衡量自己知识的掌握度，管理自己的学习时间。这就需要具有极大的主动性和自由度。
> - 工业化的追赶，海归，又陷入了比较学校名气的漩涡
>
> 从（1）读过来的，两篇连着读，感触很大

2022.01.05 12:47:27

[花刺子模的信使问题](https://m.vrrw.net/hstj/17892.html)

> 相传花刺子模是一个东亚的国家，那里的君王会对传达好消息的信使给予奖励，会把传达坏消息的信使关进老虎笼子。
>
> 文章是王小波对这一现象的分析和思考，类比当下我们现实生活中（职场、学校等等）的种种情况，还是很有体会和同感的。

2022.02.27 22:48:39

[加班与效率](https://coolshell.cn/articles/10217.html)

> 反思，效率到底是什么？创造的价值/总工作量（**有用功/总功**）
>
> **1）增加有用功**
>
> - 你得多问问你的需求方，为什么要加这个需求？干这个事到底有多大的价值？能让多少人受益？
> - 你得多问问你的需求方，能不能稍微简化一下需求，这样可以让我付出的努力更少一些？
> - 你得要多去思考一下，你是在干一个建筑队的活呢？还是在干一个装修队的活？
> - 你得要多去思考一下，业务上和用户的最大的痛点是什么？
>
> 关于增加有用功，再说两点：
>
> - 像乔布斯那样，告诉你的产品经理或是业务方，你现在提的 10 需求，我只能做 3 个，会是哪 3 个？为什么是这 3 个？**有用功的来源不是拼命做需求，而是砍需求。**
>
> - **关于创造价值，我们要干的不是像百度的“竞价排名”那样，把钱从别人口袋里搬运到自己的口袋里，而是要像“英国工业革命”或是“硅谷”那样，把价值真正的创造出来**。
>
> **2）降低总功**
>
> - 你得多问问自己，你有多少时间是在干一些支持性而不是产出性的工作？
> - 你得多问问自己，有没有残酷无情地减少重复劳动的劳动密集型的工作？
> - 你得多问问自己，自己的管理者和员工的能力和素质有没有在降低你的团队执行的成本？
>
> **3）形成合力**
>
> 评估项目价值的方法：T-shirt size estimation（项目价值 - 耗费人力）

[Uncomfortable](https://alexanderell.is/posts/uncomfortable/)

> 非常美的文字去形容作为一个程序员去解决自己的 uncomforable time.
>
> Slowly, over time, the mist starts to clear up. Suddenly you can see how things are connected. After a chat with a coworker, a deep-dive into the code, or a [walk around the block](https://alexanderell.is/posts/trust-in-your-unconscious/), something clicks, and some of the pieces start falling into place. The mist transforms into an outline, the outline into a conversation, the conversation into a diagram, the diagram into a few pull requests, the pull requests into follow up pull requests, and finally this vague problem has been translated from that amorphous blob into concrete lines of code.

[关于副业](https://catcoding.me/p/side-hustle-for-programmer/)

> 依旧是 catcoding 的博文。自己对副业的思考也是不急着做，在职场先好好摸爬滚打，看看机会，多思考、沉淀和收集信息吧，寻找机会，等过几年工作遇到瓶颈了，可以搞搞。
> 摘录下总结：
> _技术通常不是最重要的，重要是有效地解决问题和满足真实世界的需求。_ > _如果还不清楚自己想做什么，可以先从建立个人品牌着手，或者其他任何有复利效应、能复用自己的优势和资源、或者能提高自己的事情，很多事做起来了才能有些新想法。_ > _副业可能是为了挣钱，自由，探路，兴趣等等。做得不好也不必焦虑，上班低头做事，副业抬头看路，带着一种探索的心态来做副业就很好。_

[20 年编程经验](https://alexewerlof.medium.com/my-guiding-principles-after-20-years-of-programming-a087dc55596c)

> 做一些摘录
>
> Deprecate yourself. Don’t be the go-to person for the code. Optimize it for people to find their way fixing bugs and adding features to the code. Free yourself to move on to the next project/company. Don’t own the code or you’ll never grow beyond that.
>
> Realize that every code has a life cycle and will die. Sometimes it dies in its infancy before seeing the light of production. Be OK with letting go. Know the difference between 4 categories of features and where to put your time and energy:
>
> - **Core:** like an engine in a car. The product is meaningless without it.
> - **Necessary:** like a car’s spare wheel. It’s rarely used but when needed, its function decides the success of the system.
> - **Added value:** like a car’s cup-holder. It’s nice to have but the product is perfectly usable without it.
> - **Unique Selling Point:** the main reason people should buy your product instead of your rivals. For example, your car is the best off-road vehicle.
>
> When making decisions about the solution all things equal, go for this priority: **Security** > **Reliability** > **Usability (Accessibility & UX)** > **Maintainability** > **Simplicity (Developer experience/DX)** > **Brevity (code length)** > **Finance** > **Performance**，But don’t follow that blindly because it is dependent on the nature of the product. Like any career, the more experience you earn, the more you can find the right balance for each given situation.
>
> Get out of your comfort zone. Learn every day. **Teach** what you learn. If you’re the master, you’re not learning. Expose yourself to other languages, technologies, culture and stay curious.
>
> Don’t do **speculative programming**.
>
> Software is more fun when it’s made together. Build a sustainable **community**. Listen. Inspire. Learn. Share.

[Life is not short](https://dkb.show/post/life-is-not-short)

> 生命并不短暂，只是我们浪费的太多了时间。
>
> 做一些摘录
>
> Putting things off for the future is the biggest waste of a life. **You deny yourself the present by promising the future.** You’re relying on the future, which is outside of your control, and abandoning the present, which is the only thing you can control.
>
> The whole future lies in uncertainty – live immediately.
>
> The part of life we really live is small. All the rest is not life, but merely time.

[2050 年的我们应该知道什么](https://www.wired.co.uk/article/yuval-noah-harari-extract-21-lessons-for-the-21st-century)

>

[哪些书应该读？在哪里应该划线？](https://sspai.com/post/44427)

> 读书，如果是以学习为目的，如果不能过目不忘，就需要划线。
>
> 文章基于《一流的人讀書，都在哪裡畫線？》一书，讲了读书改怎么选书、如何划线（关注什么）、怎么读。。。

[十年编程经验](https://thorstenball.com/blog/2022/05/17/professional-programming-the-first-10-years/)

> 做点摘录：
>
> Nothing really matters, except bringing value to the customer
>
> Perfection is unachievable
>
> Perfectionism is a trap
>
> Knowing the full stack
>
> Negativity begets negativity
>
> Code has mass
>
> Programming as a part of my life

[软技能](https://sspai.com/post/44653)

> 书目推荐（已经下单了，早日读完！）
>
> 我们的有效产出取决于我们**专注**的时间；
>
> 有效的事前计划和事后回顾是提高生产力的重要方法。
>
> 专注的动量效应——如果由于惰性不愿意开始工作，可以先试着硬着头皮开始工作 15 分钟。

[提问的智慧](https://mp.weixin.qq.com/s/q461so9lWk4FKJGZ-p7Vcg)

>

[高维思考](https://fs.blog/second-order-thinking/)

> 尝试高维度的思考吧，结合系统性、交互、时间，这三个要素。

[antfu move to paris](https://antfu.me/posts/bonjour-paris)

> 推特刷到这条，就是说很羡慕和向往了，自己也要努力

2023

[ADEPT method](https://betterexplained.com/articles/adept-method/)

> ADEPT 学习方法（to internalize a new concept）
>
> **_Use an Analogy, Diagram, Example, Plain-English description, and then a Technical description._**
>
> 从类比 -> 画图形/图表（可视化）-> 尝试（实践）-> 简单语句的描述 -> 技术性表达（系统化），这几个步骤来学习一个新知识
>
> **是一个需要自我 check 的 mental checklist，改进自己的学习顺序（从模糊 -> 具体）**
>
> 最后：BE ADEPT
>
> - Brevity [is beautiful](https://betterexplained.com/articles/brevity-is-beautiful/).
> - Empathy makes us human.

[tiny projects](https://tinyprojects.dev/posts/i_spent_two_years_launching_tiny_projects)

> 作者花了两年时间发布了不少的小项目，还能赚到钱，很不错！
>
> _Each morning I sit down with a coffee and bash out some project code. It's a hobby I love, and one that's starting to generate some decent passive income now._ 很喜欢这种感觉
>
> 我也有一个 projects list，那就干起来吧！
>
> _to start trying one idea each week in its tiniest form._
>
> 最后还是挺佩服作者能将这么多小想法落地，并且还能赚钱，商业模式也搞起来了。

[用 github 仓库记录](https://github.com/yihong0618/gitblog/issues/209)

> Mark，实践一下自己的记录工作流！

[People Die, but Long Live GitHub](https://laike9m.com/blog/people-die-but-long-live-github,122/)

> 挺有启发的一篇文章，百年之后我们的信息还会在吗。
>
> _几十几百年后，GitHub 将成为世界上最大的数字公墓，注册用户大部分都已去世，然而个人主页，项目，commit 历史 还述说着他们生前做过的事——就比如 Joe 的[博客](https://joearms.github.io/)。_
>
> _人有两次死亡，第一次是肉体，第二次是被人忘记_

[Stay positive mode for creative work](https://www.psychologicalscience.org/news/releases/a-positive-mood-allows-your-brain-to-think-more-creatively.html)

> Generally, positive mood has been found to enhance creative problem solving and flexible yet careful thinking
>
> And music is an easy way to get into a good mood.

2023.03.30 14:43:23 +0800

[Aaron Swartz' Quotes](https://www.goodreads.com/author/quotes/6893150.Aaron_Swartz)

> “People shouldn’t be forced to categorize themselves as “gay,” “straight,” or “bi.” People are just people. Maybe you’re mostly attracted to men. Maybe you’re mostly attracted to women. Maybe you’re attracted to everyone. These are historical claims — not future predictions. If we truly want to expand the scope of human freedom, we should encourage people to date who they want; not just provide more categorical boxes for them to slot themselves into. A man who has mostly dated men should be just as welcome to date women as a woman who’s mostly dated men.
>
> So that’s why I’m not gay. I hook up with people. I enjoy it. Sometimes they’re men, sometimes they’re women. I don’t see why it needs to be any more complicated than that.”
> ― **Aaron Swartz**
>
> 搜了下作者，好家伙 [Aaron Swartz](https://en.wikipedia.org/wiki/Aaron_Swartz#) 神仙程序员，开发了 RSS、web.py 和 Markdown。OMG。不过他 1986 年生，2013 年就去世了。He is often credited as a martyr and a prodigy。去世后被加入 Internet Hall of Fame.
>
> [github](https://github.com/aaronsw)

---

### 【技术】

[(80 封私信 / 81 条消息) 2020 国内公司前端团队都在搞些什么? - 知乎](<Reading%20List%2068c05d9b17b04eac936dcb715058a8ab/(80%20%E5%B0%81%E7%A7%81%E4%BF%A1%2081%20%E6%9D%A1%E6%B6%88%E6%81%AF)%202020%20%E5%9B%BD%E5%86%85%E5%85%AC%E5%8F%B8%E5%89%8D%E7%AB%AF%E5%9B%A2%E9%98%9F%E9%83%BD%E5%9C%A8%E6%90%9E%E4%BA%9B%E4%BB%80%E4%B9%88%20-%20%E7%9F%A5%E4%B9%8E%20e86ca9b16d4047499354a9195bcd6371.md>)

[畅销书《深入浅出 Vue.js》作者，在阿里淘系 6 个月的收获成长](Reading%20List%2068c05d9b17b04eac936dcb715058a8ab/%E7%95%85%E9%94%80%E4%B9%A6%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAVue%20js%E3%80%8B%E4%BD%9C%E8%80%85%EF%BC%8C%E5%9C%A8%E9%98%BF%E9%87%8C%E6%B7%98%E7%B3%BB6%E4%B8%AA%E6%9C%88%E7%9A%84%E6%94%B6%E8%8E%B7%E6%88%90%E9%95%BF%20e966e7d788784574ada3bee7411836b6.md)

[APP 设计模式之——导航设计 - 知乎](Reading%20List%2068c05d9b17b04eac936dcb715058a8ab/APP%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E2%80%94%E2%80%94%E5%AF%BC%E8%88%AA%E8%AE%BE%E8%AE%A1%20-%20%E7%9F%A5%E4%B9%8E%209b76d30ef8904637bfca76b499c42177.md)

[Copy of Redux 数据流管理架构有什么致命缺陷,未来会如何改进? - 知乎](Reading%20List%2068c05d9b17b04eac936dcb715058a8ab/Copy%20of%20Redux%E6%95%B0%E6%8D%AE%E6%B5%81%E7%AE%A1%E7%90%86%E6%9E%B6%E6%9E%84%E6%9C%89%E4%BB%80%E4%B9%88%E8%87%B4%E5%91%BD%E7%BC%BA%E9%99%B7,%E6%9C%AA%E6%9D%A5%E4%BC%9A%E5%A6%82%E4%BD%95%E6%94%B9%E8%BF%9B%20-%20%E7%9F%A5%E4%B9%8E%20974bd4a3650f4d91bcf59615819c98fb.md)

[Workspaces | Yarn](Reading%20List%2068c05d9b17b04eac936dcb715058a8ab/Workspaces%20Yarn%200cb8bce2348447d7a2373805ef5883ac.md)

[阿里前端委员会主席圆心：未来前端的机会在哪里？-阿里云开发者社区](Reading%20List%2068c05d9b17b04eac936dcb715058a8ab/%E9%98%BF%E9%87%8C%E5%89%8D%E7%AB%AF%E5%A7%94%E5%91%98%E4%BC%9A%E4%B8%BB%E5%B8%AD%E5%9C%86%E5%BF%83%EF%BC%9A%E6%9C%AA%E6%9D%A5%E5%89%8D%E7%AB%AF%E7%9A%84%E6%9C%BA%E4%BC%9A%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F-%E9%98%BF%E9%87%8C%E4%BA%91%E5%BC%80%E5%8F%91%E8%80%85%E7%A4%BE%E5%8C%BA%208bf98a609696429abe4c2a5a8d78385a.md)

> 服务搭建、serverless、智能化、IDE
>
> 效率、质量、体验

[用 github-page 做短链服务](https://github.com/nelsontky/gh-pages-url-shortener)

> 包括[这篇](https://zhuanlan.zhihu.com/p/339832422)国人作者搬运的，利用 github 仓库做 db，github-page 的 `404.html` 来做查 db 和重定向

[Evan You interview](https://evrone.com/evan-you-interview)

https://umaar.com/dev-tips/242-considerate-javascript/

> 如何根据终端的配置来进一步优化 UX 呢?这篇文章给出了一些例子.

2021.01.09 23:25:46

[TensorFlow.js intro](https://www.youtube.com/watch?v=dDIk1Tmnj9A&ab_channel=GoogleChromeDevelopers)

> 油管视频，介绍了 ai ml 以及 tf.js 的一些有趣应用，以及谷歌在线训练，挺有意思

[chakra-ui](https://chakra-ui.com/)

> react ui 组件库，快速构建应用

[Tailwindcss](https://tailwindcss.com/):star::star::star:

> 纯 css ui 库，很赞，解决了很多 css 的痛点，极速构建应用！

[来自新时代的 CSS](https://mp.weixin.qq.com/s/pPtzhXbAaXfoTV2q3u0Dww)

> 好文，从历史的角度讲了新时代对于 CSS 模块化、兼容、预处理、规范化、可扩展性的各种方法
>
> 值得继续深入的：
>
> - [CSS Houdini](https://developer.mozilla.org/en-US/docs/Web/Houdini)：一套底层的 API 提供给开发者写 js in css，来创建一些浏览器未支持的自定义特性
>
>   - https://slides.iamvdo.me/css-houdini/#/ 上面很多有趣的特效！
>   - https://iamvdo.me/en/blog/css-houdini 博客介绍
>
> - CSS 界的 Babel -- [PostCSS](https://preset-env.cssdb.org/)
> - 强大的网格系统 -- [LostGrid](https://github.com/peterramsing/lost)
> - [cssdb](https://cssdb.org/)：postcss-preset-env 的实现基准，主要就是 CSS 的新功能功能及这些功能从提出到成为标准时所在的进程

[Youtube 7 trending js library in 2021](https://www.youtube.com/watch?v=2wucLthrUjw)

> 介绍了 7 个有趣好用的 js 库
>
> - nipple.js：virtual joystick library，就是玩游戏的虚拟摇杆
> - intro.js：能够实现页面功能介绍引导
> - [Tesseract.js](https://github.com/naptha/tesseract.js)：OCR
> - faker.js：造假数据的库
> - editor.js：编辑器
> - popper.js：tips 库
> - ## three.js：webgl

[Youtube design trending in 2021](https://www.youtube.com/watch?v=5RluSnRPRbI)

> 2021 UI 设计大趋势
>
> - 3D 元素
> - glassmorphism：没搜到这个单词，感觉是毛玻璃片的意思，可以看[这篇文章](https://uxdesign.cc/glassmorphism-in-user-interfaces-1f39bb1308c9)继续学习。其实已经有很多 panel 是这种毛玻璃片透明 or 模糊的了，挺喜欢的
> - colorless：色彩尽量少的，黑白最好，我喜欢
> - dark mode
> - animated illustrated in UI：感觉字节现在就有吧，UI 中的简单动画能增加很多活力
> - aesthetic minimalism：极简风，我爱了，但是真的做的好看好难哦
> - immersive interface：仿真的界面，让场景有真实效果的动效

2021.01.31 11:51:58

[glassmorphism](https://uxdesign.cc/glassmorphism-in-user-interfaces-1f39bb1308c9)

> 毛玻璃片的 UI 风格，苹果用的已经很多啦
>
> 文章介绍了一些 UI 注意点
>
> - 背景选择
> - 深度与透明度
> - Accessibilty 元素的可点击范围
> - 边框细节

2021.02.13 11:02:25

[写给前端的原生开发基础入门](https://zhuanlan.zhihu.com/p/340410273)

> 乍一看会觉得原生开发的概念和现在前段框架的概念类似？
>
> - [Retained mode](https://en.wikipedia.org/wiki/Retained_mode):
>
>   - in CG libs, client 调用底层函数并不会立即执行 render 操作，而是改变（update）框架内部维护的一个 model 对象（list），This allows the library to optimize when actual rendering takes place along with the processing of related objects. 有点像 React or Vue 的 vm 概念了哈？
>
> - [AOT & JIT(Angular2 as example)](https://levelup.gitconnected.com/just-in-time-jit-and-ahead-of-time-aot-compilation-in-angular-8529f1d6fa9d)
>
>   - AOT(Ahead of time):
>     - 在 build 阶段就将代码编译到机器指令集（在浏览器上就是 js bundle）
>     - source 更小，不需要下载 compiler 的代码
>   - JIT(Just in time):
>     - 在 runtime 的时候再进行变异
>     - source 更大，需要下载 compiler
>   - ![Image for post](_imgs/reading_list.assets/1*a15BveUQ7cFyV0P8CwLUCg.png)
>   - JIT 更适合在 development 模式，AOT 更适合生产模式
>
> - Object-C：
>
>   - 方括号语法
>
>     - 用 send message 的语义去理解
>
>     - ```objective-c
>       // 另一种初始化方式，即先发 alloc 消息，再发 init 消息
>       NSDate* now = [[NSDate alloc] init];
>
>       // 初始化一个 NSCalendar 日期实例
>       NSCalendar* obj = [NSCalendar currentCalendar];
>
>       // 给实例发多个参数的消息
>       // 消息名为 ordinalityOfUnit:inUnit:forDate:
>       NSUInteger day = [obj ordinalityOfUnit:NSDayCalendarUnit
>                                       inUnit:NSMonthCalendarUnit
>                                      forDate:now];
>       ```

[Vite intro](https://www.twitch.tv/videos/911252528)

> you 大的 twitch 访谈？聊天？
>
> 大致介绍了 vite 是个什么东东，还挺有意思
>
> - Framework agnostic
> - Es module
> - Chunk

2021.02.17 10:46:43

[why esbuild is fast](https://esbuild.github.io/faq/#production-readiness)

> 了解了 esbuild，才知道用 non-js 的语言写的打包器居然依旧很久了，而且很厉害
>
> - golang 写的，充分利用了*多线程*并行的特性
> - 编译成二进制在命令行使用，而不是 JIT 的形式（用 node 去解析 js 写的 bundler）
> - 可以看到 JS 语言的局限性，或者说 JS 的特性更适合在浏览器场景使用？而在其他场景必然会有性能上的缺陷

2021.03.02 16:06:49

[best of js 2020](https://risingstars.js.org/2020/en)

> js 相关工具生态一年的上升趋势

https://github.com/Kaiyiwing/qwerty-learner-vscode

> 分享个 vscode 插件 可以摸鱼的时候练单词

[QR code generate on Chrome 88](https://www.androidpolice.com/2021/02/04/chrome-84-brings-new-dino-themed-qr-codes-to-android-and-desktops/)

> chrome 自带生成页面 QR code 能力
>
> - chrome://flags -> sharing-qr-code-generator -> relaunch chrome

【nice idea】[trace user by favicon](https://supercookie.me/workwise)

> 背景：
>
> - 获取用户数据
> - 大量网站的 cookie
> - 催生了下面的 supercookie
>
> 很不错的一个想法：
>
> - 利用了浏览器对 favicon 的强缓存（切 VPN、更换网络、重启等都不会清除）的功能
> - 在 server 端生成用户的唯一标识 id，转为二进制，重定向访问 log2(id) 次的 subpath 下发对应 bit 为 1 的 favicon 文件让浏览器缓存（写操作）
> - 用户再次访问网站的时候会再次经历重定向，server 记录 favicon 的访问 bit 位，以此来获得用户的 id（读操作）
> - 扩容能力和性能都还不错（个人感觉重定向还是有点慢啊）
>
> github 地址：https://github.com/jonasstrehle/supercookie
>
> - node 写的，express + typescript

2021.04.05 17:19:24

[react concurrent-mode](https://reactjs.org/docs/concurrent-mode-intro.html)

> 让 UI 更新是可以被 interruptted 的，能够带来更好的性能和体验
>
> 结合了 git 分支和图形学 double buffering 的思想，很妙啊

2021.05.03 20:47:33

[Immediate mode GUI](https://caseymuratori.com/blog_0001)

> retained gui：create -> update -> callbacks

[about mipmaps](https://cgl.ethz.ch/teaching/former/vc_master_06/Downloads/Mipmaps_1.pdf)

> why mipmap？
>
> - 发现其实在 games101 7-9 课程中学到过，为了更好的在 texture 太大、点太小，可以在某个下采样的 map 上更好的取到 texture
>
> 什么是 mipmap
>
> - mip = "multum in parvo" (lat.: many things in small place) 来自拉丁文
> - 类似图像金字塔，2 的 pow，会需要额外的 1/3 数据量
> - by downsampling the original texture
>   - 最近点、box filter、gaussian filter
> - 三线性插值（第三重在 level 直接插值），更加平滑

[Tiff](https://www.programmersought.com/article/8912800630/)

> **Tag Image File Format**
>
> TIFF is a mark-based file format that is widely used for the storage and conversion of images that require high image quality.
>
> 在 file header 中有 label，能在一个文件中处理多个图像

[what is raw in photography](https://www.findingtheuniverse.com/what-is-raw-in-photography/#What-is-RAW-in-Photography)

> RAW 是什么
>
> - 相机拍摄得到的图片原始数据
> - 统称 RAW，而不是具体的某个相机厂商的格式：.cr2 or .cr3(Canon RAW), .nef(Nikon), .raw(Android)
>
> JPG 其实就是 JPEG(Joint Photographic Experts Group)
>
> - This is often shortened to JPG, _as a throwback to a time when file extensions could only be three letters_. So a JPG file on your hard drive would look like “Image.JPG”. There is no difference between a JPG and a JPEG, they are the same.
>
> [白平衡 white balance](https://www.cambridgeincolour.com/tutorials/white-balance.htm)
>
> - 可以理解就是色温？想象一张白纸放在一个钨丝灯泡（tungsten bulb）下
>
> 不建议拍 raw 的一些原因
>
> - 没有足够时间去后期编辑
> - 连拍场景可能会 brust，因为 raw 文件太大了，写入硬盘会比较慢（相比 jpg）

[tiny-wins](https://joelcalifa.com/blog/tiny-wins/)

> github pr 的状态可以在 favicon 上显示
>
> 下面这张图挺好
>
> - small change add up to big win
> - 发现/解决一些**高频事情中的痛点（时间浪费）**
> - Getting your personal pet peeve（个人烦恼） fixed is powerful, often more so than new, more substantial features.
>
> btw 这篇文章文笔还挺好的

![Matrix of low to high effort and low to high impact](_imgs/reading_list.assets/evaluation.png)

【好文】[跨平台动态化容器方案优化（非常切合工作哈哈）](https://mp.weixin.qq.com/s/0QViGHkt6R5fOZms-EpwAA)

> 比较全面的讲了目前（2021 前后）移动互联网应用跨平台解决方案的整体架构、优化方案
>
> 摘录一些：
>
> 开头：\*随着互联网红利的消失，整个移动市场的关注从“流量”转成了“留量”，大部分的移动产品也都告别了初期的抢占市场，**进入了 A/B 实验和快速试错的阶段，迭代速度、效果验证的压力与日俱增，效率变成了移动 App 的核心竞争力。\***
>
> - 动态化 UI 方案
> - 平台化 App
> - 小程序平台
>
> 容器化方案整体架构：
>
> - JS 做什么
> - Native 提供什么
>
> ![图片](_imgs/reading_list.assets/640.png)
>
> **为什么要跨平台？**
>
> - Write once, run anywhere
> - 提升效率（研发、运营...）
>
> 可以优化的切入点（容器 webview。。。）
>
> ![图片](_imgs/reading_list.assets/640-20210601134025347.png)
>
> P.S. 结合自己的工作，公司内部的 lynx react-lynx DSL 的动态化方案，包括所学的 CG 知识，其实能看出整个大前端（App）渲染的 pipeline：
>
> - App 容器（-> DSL -> JsVM -> ... ->）Native platform/engine -> Device GPU
>
> 还挺有意思的，可以深入的地方还是很多！

2021.06.02 19:23:17

[js functions compare](https://habr.com/ru/post/554334/)

> 俄罗斯大佬比较了 angular 的项目中 node_modules 里面有 39% 的函数是重复的，里面如何比较 js 函数的思路
>
> - 函数 `toString`
> - Uglifyjs 统一变量名
> - 遍历所有 js 文件 用 ast 解析出函数
> - 函数字符串 hash 作为文件名
> - sqlite 数据库保存信息
> - [完整的脚本](https://github.com/gurov/identical-functions/blob/master/index.js)

【TODO】[intro to multi-thread](https://www.internalpointers.com/post/gentle-introduction-multithreading)

> 一个系列的教程文章，后续继续要看 TODO
>
> - 希腊语 atom 原子性 uncuttable 原子不可再分

[webview 概述](https://mp.weixin.qq.com/s/PipKSnMQaTBhE5kSwG3DVQ)

> JS to Native：
>
> - 注入型 JSB `JavascriptInterface`
>   - 在 native 上实现实例注入到 webview 的 window 对象下面
> - 拦截型 `WebViewClient.shouldOverrideUrlLoading()`
>   - 拦截所有的 URL schema
>   - iframe.src/location.href
> - 监听？`WebChromeClient.onXXX()`
>   - 通过修改原来浏览器的 `window `某些方法，然后拦截固定规则的参数，然后分发给 Java 对应的方法去处理
>   - alert/console.log/confirm/prompt
>
> 通信原理是 JSBridge 实现的核心，实现方式可以各种各样，但是万变不离其宗。这里，推荐的实现方式如下：
>
> - JavaScript 调用 Native 推荐使用 **注入 API** 的方式。（ iOS6 忽略，Android 4.2 以下使用 WebViewClient 的 onJsPrompt 方式。）
> - Native 调用 JavaScript 则 xx 直接执行拼接好的 JavaScript 代码即可。

2021.06.23 16:44:28

[webcontainer](https://blog.stackblitz.com/posts/introducing-webcontainers/)

> 用 web 来开发 web，非常跨时代，[doc](https://github.com/stackblitz/webcontainer-core)
>
> 在浏览器中运行 node 项目，安全性，离线化，node_modules，等等
>
> 最终目的：开发抛弃一切 git，node，npm，VSCode...

[css-in-js v.s. real-css](https://pustelto.com/blog/css-vs-css-in-js-perf/)

> 比较了 css-in-js（比如 [styled-component](https://styled-components.com/) 的 runtime css）和纯 css 文件（[linaria](https://github.com/callstack/linaria)-built-time）的 web 应用的性能，具体数值没细看，而“现代框架如何渲染 css 文件”这件事情是我一直忽略没有关心过的，文中能提到几个框架可以值得学习一下。
>
> btw，在 built-time extract 出 css 文件可能是未来 css 文件发展的方向，[vanilla-extract](https://github.com/seek-oss/vanilla-extract) 和 Facebook 团队都已经开始尝试了。脸书的那个 react conf [视频](https://www.youtube.com/watch?v=9JZHodNR184)还是有点东西的。

[zerocopy](https://developer.ibm.com/articles/j-zerocopy)

> zerocopy 的技术，提升从硬盘读取数据在传送到网络的速度/性能。
>
> - 为什么？
>   - 应用读取文件传输到网络（比如：静态资源服务器）
>   - 经历了 disk -> app -> socket 的过程
>   - 每个通信过程中都会有数据拷贝操作，app 仅仅作为了一个中间缓存
>   - 却带来了多次的 kernel/user mode 交换和数据拷贝，非常低效
> - 怎么做？
>   - 类 UNIX 的 Linux 系统有直接将一个 file descriptor 传递到另一个 descriptor 的系统调用，可以避免再拷贝到 app 上下文的内存
>   - 直接将 kernel mode 中的 buffer 拷贝到 socket buffer 即可
>   - Linux 2.4 之后还有一个操作，修改了 socket buffer 的实现，zero copy 直接可以将 file descriptor 作为 index 一样 DMA 传给 NCI buffer，做到真正的 zero copy
>   - 在 Java 中的实现为 `transferTo()`
>
> 这篇文章图画的挺清楚，易懂

[react 加速工具](https://blog.bitsrc.io/5-recommended-tools-for-optimizing-performance-in-reactjs-29eb2a3ec46d)

> 先 mark 了，用到再说

[third age of JS](https://www.swyx.io/js-third-age/)

> JS 的第三个阶段（第二阶段刚过去 2009-2020，扩展和探索）
>
> In summary: Third Age JS tools will be
>
> - Faster
> - ESM first
> - Collapsed Layers (One thing doing many things well instead of many things doing one thing well)
> - Typesafe-er (built with a strongly typed language at core, and supporting TS in user code with zero config)
> - Secure-er (from dependency attacks, or lax permissions)
> - Polyglot（多语言？）
> - Neo-Isomorphic (recognizing that much, if not most, JS should run first at buildtime or on server-side before ever reaching the client)
>
> 更好的 DX 和 UX...
>
> The result of all of this work is **both a better developer experience** (faster builds, industry standard tooling) and **user experience** (smaller bundles, faster feature delivery). It is the final metamorphosis of JavaScript from site scripting toy language to full application platform.
>
> 也说到这 10 年可能就是 JS 最后的阶段了——因为有 WASM！
>
> If so - **we're in the Endgame now**.

[Git-centric workflow](https://www.netlify.com/blog/2019/09/27/git-centric-workflow-the-one-api-to-rule-them-all/?utm_source=twitter&utm_medium=gitcentric-swyx&utm_campaign=devex)

> 以 GIT 为中心的工作流，everything in Git
>
> - CD，rollback
> - AB test
> - ...
>
> 提到了 [Git lfs](https://git-lfs.github.com/)（large file storage）用 go 写的，提供：大文件 -> 本地文本指针 -> 文件上传到服务器（没细看）

[未来计算领域的 10 个预测](https://blog.container-solutions.com/10-predictions-for-the-future-of-computing)

[通过 AI 将动漫人物真实化](https://designyoutrust.com/2021/04/person-uses-artificial-intelligence-to-make-anime-and-cartoon-characters-look-more-realistic/)

> 没找到技术相关，都是图片，发现了帅气的波波

![img](_imgs/reading_list.assets/Artist-gives-human-forms-to-anime-characters-through-artificial-intelligence-6078043e1d2d8-png__880.jpg)

[emoji 作为 favicons](https://css-tricks.com/emojis-as-favicons/)

> 浏览器支持用 svg 作为 favicons，可以添加文本内容，这篇文章有例子

[react 和 IMGUI](https://www.zhihu.com/question/39093254/answer/1351958747)

> doodlewind 在知乎的回答，阐述了 IMGUI（immediate mode gui）的特点：指令式、每帧进行计算，和 React 本质上其实就不是一回事情。也讲到了对应的 GUI 范式 retained mode，也是大多数渲染接口所保留的。
>
> 同时提到了「前端」对于「渲染」的理解，个人认为前端真的只是在解决渲染逻辑上的操作，而不是渲染真正的问题（图形学才是），这点想清楚其实就不会对这个问题产生太多疑惑了。
>
> _依赖 React 做所谓「渲染」，不外乎就是在改一堆对象（DOM）的状态而已，许多 GUI 技术栈里的重点和难点根本摸不到_ 所以浏览器在 DOM 这层就已经把「渲染」的事情封装掉了 XD

[Lottie intro](https://airbnb.design/introducing-lottie/)

> Lottie 作为动画的新技术，airbnb 开源
>
> - 跨平台
> - 文件小，json based
> - 可复用

2021.12.14 13:50:49

[Rust——JS 基建的未来](https://leerob.io/blog/rust)

> 用 Rust 写的 JS 工具越来越多，逐渐来替换之前的打包/构建/lint 工具
>
> - 介绍了 rust 的一些 JS 工具：swc，Deno，esbuild，Rome
> - Rust 和 Wasm 的结合（后续可以多了解下 Wasm）
> - 展望未来：**Extensibility**，**Performance**，**WebAssembly**，**Community**

[抖音国庆小游戏 cocos](https://mp.weixin.qq.com/s/cQ9S20Uxm6lir2pa1RF2cA)

> cocos 做小游戏的介绍，自己也不会，看了也想象不出开发过程，不过既要兼顾业务需求也需要顾及性能，还挺难的。

2022.02.07 18:25:29

[sass 编译器的历史](https://mp.weixin.qq.com/s/tP_hXQ5Dc1wPKitTZ095kw)

> 从 ruby-sass，node

[React hooks](https://juejin.cn/post/7051535411042058271)

> 作者：“红脸太常见，也来唱个黑脸，**本文将站在一个「挑刺儿」的视角**，聊聊我眼中的 React Hooks ~”
>
> React hooks 在设计上的一些问题和缺陷，挺好的文章，对 hooks 的理解又多了

[JS undefined & null](https://mp.weixin.qq.com/s/aKMFjO_N8LoAKiZfW-lYTg)

> 讲述了 undefined 和 null 在 js 中的不同表现：
>
> 以及提到了底层 `typeof null` 为什么是 `object`
>
> > 对于所有的对象，它的前 `3位` 都以 `000` 作为类型标记位。在 `JavaScript` 早期版本中， `null` 被认为是一个特殊的值，用来对应 `C` 中的 `空指针` 。但 `JavaScript` 中没有 `C` 中的指针，所以 `null` 意味着什么都没有或者 `void` 并以 `全0(32个)` 表示。因此每当 `JavaScript` 读取 `null` 时，它前端的 `3位` 将它视为 `对象类型` ，这也是为什么 `typeof null` 返回 `'object'` 的原因。
>
> btw 中间的排版有点错乱。。

[一个 DNS 解析器 toy](https://jvns.ca/blog/2022/02/01/a-dns-resolver-in-80-lines-of-go/)

> 据说作者很牛
>
> 文章通过漫画讲述了 DNS 解析的过程，挺生动易懂的
>
> 对 DNS 查询的输入和返回进行了剖析
>
> 然后通过简短的 go 代码将整个 resolve 方法描述了（简化版）挺有意思

[【好文】intro of Worker Threads in Nodejs](https://yarin.dev/nodejs-cpu-bound-tasks-worker-threads/#using-a-worker-pool)

> 这篇文章主要介绍了 Nodejs 应用在处理 CPU-bound task（CPU 计算密集型任务）中可以使用的提升性能的工具/方法
>
> 基于 Nodejs 自身的运行机制（event loop，异步非阻塞 IO），对于 CPU 计算型任务会阻塞 eventloop，导致处理并发请求的吞吐量降低，文章介绍了几种方法（结合简单代码 example）：
>
> - Splitting up tasks with `setImmediate()` (single-threaded)
>   - 相当于是将一个完整任务拆成很多片段，让他们在 event loop 的间隙里执行
> - Spawning a child process
> - **Using worker threads**（文章重点，但不一定是最好方法，还是根据实际情况看）
>   - 在另一个独立的 js context（V8 eventloop）中执行（不会阻塞主线程的 eventloop）
>   - 比 child process 更好的点
>     - 更加轻量
>     - 可以共享数据
>   - 不用考虑线程间同步问题（除了 SharedArrayBuffer），可以减少 bug
>   - 使用 worker pool（有开源现成的 npm 包 [workerpool](https://www.npmjs.com/package/workerpool))减少每次创建 worker 的开销
>   - ArrayBuffer 和 SharedArrayBuffer
>
> 最后文章的 summary 部分也写的非常好，一切软件都是 trade-off，**There is no silver bullet**
>
> Successful software projects make trade-offs that enable them to excel at **their core use case**, while (hopefully) leaving some room for flexibility.

[JS Array 的 search 函数通用化](https://jasonformat.com/reusable-array-search-predicates)

> 挺有意思的编程思路，将 `filter` `find` 之类的 search 方法抽离出来，通过 `this` 来得到实现通用化
>
> - filter 之类的函数接受第二个参数就是一个对象 `thisValue` 是给 predicator 的上下文，相当于是 `fn.bind(obj)`
> - 方便单元测试
>
> 直接看他的一个普适性的例子代码，挺有意思
>
> ```js
> function matches(item) {
>   const expected = item[this.value];
>   const actual = item[this.property];
>   switch (this.comparator) {
>     case "===":
>       return actual === expected;
>     case ">":
>       return actual > expected;
>     case "<":
>       return actual < expected;
>     case "includes":
>       return actual.includes(expected);
>     case "after":
>       return new Date(actual) > expected;
>   }
> }
>
> function compare(property, comparator, value) {
>   return { property, comparator, value };
> }
>
> items.filter(matches, compare("id", ">", 40));
>
> // borrowing from the previous example:
> blogPosts.filter(matches, compare("tags", "includes", "b"));
> blogPosts.filter(
>   matches,
>   compare("published", "after", new Date(2020, 12, 15))
> );
> ```
>
> 不过唯一的不足是，绑定 this 对于性能上来说，会差一些

TODO [js 中真正的 sleep](https://jasonformat.com/javascript-sleep/)

> 如何让 js 的线程真正的 sleep，最 naive 的想法就是用 while 循环，但是对于 cpu 的占用率是非常高的
>
> 文中介绍了几种更高效的 tricky 的方法
>
> - 用 xhr 发送网络请求，service worker 进行拦截并且 timeout
> - 用 [`Atomics.wait()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/wait) 来等待一个数组的元素发生变化（worker 线程）
>
> 都是比较骚的实现，还不能完全理解，日后实践

[【好文】我做系统架构的一些原则](https://coolshell.cn/articles/21672.html)

> coolshell 的深度好文，讲架构的一些好的原则，值得反复阅读和品味

[why svelte](https://www.swyx.io/svelte-why)

> 大佬对 svelte 的一些看法，自己虽然也只是看了文档还没有实操，对 svelte 还是有很大的兴趣，从文档中能看到
>
> - mutability in svelte
> - 作者对 svelte 和 react 之间的看法，以及框架的理解/看法
> - svelte 存在的一些问题，作者自己选择框架的方式 For now, my approach is ”**Svelte for sites, React for apps**“.

[git commit template](https://gist.github.com/lisawolderiksen/a7b99d94c92c6671181611be1641c733)，[为何/如何写好 commit](https://cbea.ms/git-commit/)

> git commit 的模版，可以让我们更方便的写完更好的 commit 信息，有机会 try try
>
> A diff will tell you _what_ changed, but only the commit message can properly tell you _why_.

[浏览器被 fingerprint](https://fingerprintjs.com/blog/disabling-javascript-wont-stop-fingerprinting/)

> 概念/定义 什么是 fingerprint？
>
> - 对某一个东西的唯一标识（比如身份证、指纹信息
>
> 浏览器的 fingerprint 就是浏览网站的人的唯一标识，这个标识当然是存在服务端数据库里面的
>
> 文章介绍了禁用 js 之后仍然可以通过一系列的浏览器信息获取，通过这些信息生成对应浏览器的指纹（hash）
>
> - ip
> - http request header/UA/Client Hints/...
> - 浏览器 CSS 引擎的各种 feature（有没有开启
> - 字体信息
> - ...
>
> 脑洞十足呀，附上 [github](https://github.com/fingerprintjs/fingerprintjs)

[开发团队的效率](https://coolshell.cn/articles/11656.html)

> 团队开发的各种毛病！和现实十分贴切！

[H.264](https://sidbala.com/h-264-is-magic/)

> H.264 视频编码到底是什么（有损的视频压缩编码），文章比较生动和细致的讲了 H.264（虽然还不知道该怎么读他）所用到的压缩方法：
>
> - 2D 空间上：
>   - **entropy encoder**：信息熵不变，但是他的 representation 变了
>   - **frequency domain quantization**：频域压缩，图像处理很常用，去除低频（变化不那么大的元素），前提是其实是基于人们对于颜色变化其实不敏感
>   - **Chroma Subsampling**：颜色变化细节不敏感，去除图片区块的部分像素
> - 时序上：
>   - **Motion compensation**：
>     1. split to macro blocks
>     2. one static image I-frame，others are P-frame(predicted) or B-frame(bi-directionaly predicted)
>     3. use motion vectors to define P or B-frames
>     4. at cost of calculations
>     5. Entropy Coder to reduce the redundancy of I-frames

[weapenisation of open source](https://beny23.github.io/posts/on_weaponisation_of_open_source/)

> now: 2022.04.05 20:28:28
>
> 前不久俄罗斯向乌克兰发起了战争，在开源社区也有一些行为在做抵制俄罗斯的行为，但他们的影响面导致了一些公司依赖的软件遭到连带（collateral damage）

[utopia](https://utopia.app/)

> 非常牛的一个产品，react code with design，代码开发 + 设计软件双向同步，代码编辑器采用 vscode，设计的编辑器也非常牛啊。

2022.05.03 11:17:28

[RPC from scratch](https://alexanderell.is/posts/rpc-from-scratch/)

> 文章介绍了 RPC 的概念，并用一个 toy example 解释
>
> 烟蒂 _stub_ 模型，RPC 是一个比较抽象的设计模式（？）封装了 client 和 server 之间的通信方式（协议、接受参数、打包/解包数据、返回）
>
> 最后介绍一个正真的 RPC 框架需要满足的能力：
>
> - **Discoverability**：在网络中可被发现性，服务是否在线等
> - **RPC type**：辨别不同类型的 RPC 服务
> - **Packing**：打包/解包不同数据结构的数据，传输协议、压缩、节省带宽
> - **Generating code automatically**：只需要定义 interface，不用每次写很多重复代码
> - **Multiple languages**：cross-service and cross-language communication
> - **Error & timeout handling**：失败和超时的处理、通信
> - **Versioning**：版本控制
> - **All of the other caveats that go along with running servers**: threading, blocking, multiplexing, security, encryption, authorization… 以及其他一些运行时服务一样会遇到的问题，都需要得到很好的解决

[Thunk 是什么](https://daveceddia.com/what-is-a-thunk/)

> 这篇文章真正解答了我用 redux 以来这么久对于 thunk 的疑惑
>
> _thunk_ 这个单词本身含义就是一个能返回函数的函数（常用的 wrapper 方法）
>
> **redux-thunk** 的作用和意义就是在于能在一个 redux action 中去执行其他的 action，增加 action 的灵活性，把 action 的形态拓展成函数。
>
> _P.S. 对于 redux action 来说就是一个 pure object 包含了 type_
>
> redux-thunk 的实现其实也是运用了 redux 的 middleware，判断一个 action 是否是 function，如果是就执行他，如果不是就正常的走 `next` 方法
>
> 补充：来自 redux-thunk 源码
>
> _A [thunk](https://en.wikipedia.org/wiki/Thunk) is a function that wraps an expression to delay its evaluation._
>
> 维基百科：_Thunks are primarily used to **delay a calculation until its result is needed**, or to insert operations at the beginning or end of the other subroutine._
>
> 所以 thunk action 他一定是一个函数（区别于 pure object 的 action）
>
> And 看了源码，短短 50 行，很厉害，单测也很完备！不愧是 Dan。

[Youtube State of CSS](https://www.youtube.com/watch?v=Xy9ZXRRgpLk)

> 介绍了 2022 年的一些新 css 特性，很强大。

[浅浅了解一下 Web3 开发](https://guoyu.mirror.xyz/RD-xkpoxasAU7x5MIJmiCX4gll3Cs0pAd5iM258S1Ek)

> Web3 创业的大佬（郭宇，貌似就是之前在字节自由的人），介绍了 Web3 开发的基本全部的部分吧。

[macos 系统界面里的 webview](https://blog.jim-nielsen.com/2022/inspecting-web-views-in-macos/)

> 命令行中输入
> defaults write NSGlobalDomain WebKitDeveloperExtras -bool true
> defaults write -g WebKitDeveloperExtras -bool YES
> 可以在一些界面通过右键审查元素，但是目前只发现在设置中**家人共享**可以，还挺有意思的，能看到很多源码，比如 html 就是用 react 写的，有一个自定义 hook，

```typescript
import { useState, useEffect } from "react";

// This hook will set a flag once the requested image is loaded. This should help with large images not being downloaded fast enough.
const usePreloadedImage = (imageUrl: string): boolean => {
  const [isImagePreloaded, setIsImagePreloaded] = useState(false);

  useEffect(() => {
    const preload = new Image();
    preload.src = imageUrl;
    preload.onload = () => {
      setIsImagePreloaded(true);
    };
  }, []);

  return isImagePreloaded;
};

export default usePreloadedImage;
```

[可以检查素数的正则](https://www.noulakaz.net/2007/03/18/a-regular-expression-to-check-for-prime-numbers/)

> 这篇文章挺久远的，07 年的
> 先看下最终的这个正则：`/^1?$|^(11+?)\1+$/`
> 这个正则有两个部分
>
> 1. 检查是否是 0 or 1
> 2. 用 11 开始匹配，`\1` 是指前一个部分匹配到的变量，先用 `11+` 匹配有多少个，然后在看是不是以这个的倍数结尾的
>
> 挺有意思的，但是呢，需要将数字 n 转换成 `'1'.repeat(n)`，然后在进行 test
>
> 这个步骤的分析其实文章里也写的很清楚，其实主要是转换成了 n 个 1 的字符串，在第二部分的正则中会去开始从最小的素数 2（两个 1 `11`）来猜这个数是否是它的倍数（`\1+$` 倍数结尾），如果不满足，正则引擎会继续走 `11+`，用 3 开始猜，以此类推。
>
> 不得不说用正则来做这个计算还是很骚的，但是问题就在于对于大数的匹配有性能和内存的问题。。

[favicon 的分析](https://iconmap.io/blog)

> 爬取了 100k 个网站，下载了 425,909 个 favcion(favorites icon)
>
> 如何获取 favicon 的：link（icon、apple-touch-icon），/favicon.ico，/apple-touch-icon.png，icons from link rel=“manifest” JSON
>
> 逐步分析了 icon 的大小/下载速度、文件类型、主导色（紫色、白色、橙色、蓝色、黑色、...）
>
> 爬虫方法、分析方法

[mac 个性化菜单栏](https://felixkratz.github.io/SketchyBar/setup)

> [Github](https://github.com/FelixKratz/SketchyBar)
> 挺不错的，但是有点难搞，装了好久，原生的菜单栏突然去掉还挺尴尬的。

[VSCode CodeTour](https://marketplace.visualstudio.com/items?itemName=vsls-contrib.codetour)

> 还不错的一个插件！可以 tell the story of the code，适合给别人介绍如何阅读代码，要是每个开源仓库都能配这个就好了哈哈

[VSCode dev](https://code.visualstudio.com/blogs/2021/10/20/vscode-dev)

> 支持 web 版的编辑器了！
>
> - 浏览器可以访问/修改本地文件，chrome 支持的 api！
>
> - 当然对于一些场景的体验会差一些
>   - 插件
>   - 语言的 language server

[Product-first or Code-first](https://thezbook.com/code-first-vs-product-first?x-host=thezbook.com)

> 两类程序员：1）code-first 专注代码写的是否优雅、是否用了最新的技术、架构设计、...2）product-first 聚焦的目标是最终产品是不是 work well。
>
> 这里的 product 泛指一切代码的产出，api、sdk、页面、产品、...
>
> 一个好的产品意味着好的代码，不好的产品意味着不好的代码，可以去问这么两个问题：
>
> 1. 产品是否 work well
> 2. 产品是否能 produce quickly
>
> _Programming is about building products that solve problems for users not about writing beautiful code for its own sake._
>
> 还是挺有收获的，也能在生边看到这两类程序员，自我评估是两者兼备吧，一切都是 tradeoff，需要不断的做好这两者的平衡。

[protocols not platforms](https://knightcolumbia.org/content/protocols-not-platforms-a-technological-approach-to-free-speech)

> twitter 的 CEO 都收到鼓舞的文章，很长，论述了当前社交网络从大平台掌控到基于协议的系统/服务，的一些好处：free speech and innovation
>
> 大致内容：protocol 和 platform 能做的，现在大的 platform 存在的问题，protocol 的优势/劣势，怎么做，结论

[http 连接池](https://www.cnblogs.com/xrq730/p/10963689.html)

> 浅了解一下，顺便复习一下网络知识
>
> 解决的目标：
>
> - QPS 暴增的时候，解决每次 http 建立连接的开销，降低并发请求的总耗时
>
> 长/短链接：
>
> - http1.1 开始默认长连接，能在一个 TCP 连接上传递多个 HTTP 请求
>
> 长连接
>
> - 客户端发送一个 Connection: keep-alive 的 header，表示需要保持连接
> - 客户端可以顺带 Keep-Alive: timeout=5,max=100 这个 header 给服务端，表示 tcp 连接最多保持 5 秒，长连接接受 100 次请求就断开，不过浏览器看了一些请求貌似没看到带这个参数的
> - 服务端必须能识别 Connection: keep-alive 这个 header，并且通过 Response Header 带同样的 Connection: keep-alive，告诉客户端我可以保持连接
> - 客户端和服务端之间通过保持的通道收发数据
> - 最后一次请求数据，客户端带 Connection：close 这个 header，表示连接关闭
>
> 记录：
>
> - http 的 keep-alive 是为了**复用已有连接**
> - tcp 的 keep-alive 是为了**保活**，即保证对端还存活，不然对端已经不在了我这边还占着和对端的这个连接，浪费服务器资源，做法是隔一段时间发送一个心跳包到对端服务器，一旦长时间没有接收到应答，就主动关闭连接
>
> TSL 层的优化：每次 HTTPs 的连接都会进行 tsl 的握手，文中提到两种优化思路（都是缓存/解析）
>
> 连接池个数的设置，不太好控，有没有什么自适应的方法呢？

[reduce 来按序 resolve promise](https://css-tricks.com/why-using-reduce-to-sequentially-resolve-promises-works/)

> reduce => Take a collection of things, and reduce them to a single value
>
> 其思路就是将多个 promise 按顺序挂到一个 promise 的 then 上

[js framework 的时代](https://www.pzuraq.com/blog/four-eras-of-javascript-frameworks)

> 粗读了一下，有空再看一遍。
>
> 前端框架的演进，未来又会是怎么样的呢。

【好文】[程序员的喵 weekly18](https://catcoding.me/p/weekly-18/)

> 这期的周刊不错，收藏下（2022/7/2）
>
> 1. 程序员的软技能：mark，是个需要不断学习的东西。“写代码只是个门槛，本质上来说在公司工作，是和同事一起帮公司解决问题，所以沟通和协作特别重要。特别是要从广度上增加自己的影响力，沟通力起决定性作用。”
>    1. [软技能演讲 ppt（slidev）](https://github.com/forrestchang/programmer-soft-skills)
> 2. “人一生的三次死亡”。程序员写的代码可能还在世界上的某处运行着，这样也许就不会被世界遗忘吧。

2022.07.14 12:46:47

[重新构想 atomic css](https://zhuanlan.zhihu.com/p/425814828)

> 依旧是 antfu 大佬的文章（[原文](https://antfu.me/posts/reimagine-atomic-css)） 以及他的作品 [unocss](https://github.com/unocss/unocss)
>
> 文章也是剖析了当下（写于 21 年 10 月）atomic css 方案的一些问题：（tailwind 为主）
>
> - 无用的 css 过多，生成器的流程需要变革
> - 不够定制化，维护成本
> - ...
>
> 介绍了 windicss，先扫描再生成
>
> 最后介绍他自己的 unocss，完全可以自定义的、高灵活度的 css 生成引擎
>
> 很是牛逼。

[Pure CSS Icon](https://antfu.me/posts/icons-in-pure-css)

> 依旧是 antfu 的
>
> 纯 CSS 图标
>
> - 使用 DataURI
> - 可缩放（scalable），用了 `em` 单位
> - Colorable，纯色图标用 mask 和 `background-color: currentColor`
>
> 使用：unocss 的 preset
>
> 以及 egoist 他是[怎么用](https://egoist.dev/using-unocss-for-icons)的（updated on 2023.03.30 19:13:28 +0800）

[hide a photo inside another](https://avestura.dev/blog/hide-a-photo-inside-another-photo)

> 文章介绍了一种在一张图片中藏另一张图片的 trick，能做水印、存储、....
>
> 一种密码学（steganography）
>
> 利用 LSB(Least significant bit)，将图片以二维矩阵的结构（考虑单个 channel），每个元素用二进制表达，当我们修改最右的一位之后，新的图片和原图其实看不出什么差异
>
> 于是就能用每一个像素点的最后一个 bit 来存储需要 hide 的图片。所以 hidden photo 是有大小限制的：还得是个正方形，边长 = `sqr(ori_H * ori_W / 8)`
>
> 限制：对于有损压缩的图片格式（如 jpeg），在取图的时候可能就会损失惨重，噪音也会很大。
>
> 扩展：
>
> - 想象一下如果用两位最低 bit 取存，是不是能存更大的图片
> - 如果再加入一些 header 信息，比如 size 之类的 hidden photo 会更加丰富

[Tilg](https://github.com/shuding/tilg)

> 源码阅读 **`useTilg`**
>
> 这是一个 react hooks，tiny logger to help you debug your components. 详细功能可以去 [github](https://github.com/shuding/tilg) 看
>
> 主要提炼核心的几个点：
>
> 1. 整体结构是在每次 render 中输出 log：
>    1. 组件名，props，变更属性，自定义的 log 信息
> 2. 在 React 环境如何获取到当前渲染组件的信息：
>    1. 首先是组建名，非常骚，用了 `React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED`，但这么写在生产环境大概率是会报错的（uglify js），当然它 README 的[最后](https://github.com/shuding/tilg#faq--caveats)也写了不要自己再用这种东西实现 hh
>    2. 如何统计同一个组件多次 render，用了 WeakMap（见[[../02learning_notes/front_end_notes/js/ES6]]）存了一个数组 `WeakMap<ComponentId, HookPath[]>`，这里的 `HookPath` 就是每次调用 `useTilg` 的时候都会去看看是在哪里调用的，如果是不同的调用路径，就认为是同一个组件的另一个实例。BTW 为什么用 WeakMap，如果一个组件直接从 React 上下文去除掉了，也没必要继续存了（我猜的）
>    3. 怎么获取调用 path？给我惊到了，通过对 `new Error().stack` 的处理，能拿到当前 call 的调用栈，里面包含了 caller 和代码 path，做了正则匹配提取。
>    4. 在组建中多次 hook 调用只会执行第一次，用了一个闭包的 id 做的。
> 3. MarkDown 的实现
>    1. 不得不说为了支持 md，足足得多 200+行代码，真是煞费苦心。
>    2. 支持了 node 和 webview 环境，详细的可以看代码。。
>
> 整个代码还是比较精炼好懂的（除了 markdown 的部分。。），确实如同作者说的非常 hacky。哈哈。

[【open source】CONTRIBUTING.md 是什么](https://mozillascience.github.io/working-open-workshop/contributing)

> 介绍了 CONTRIBUTING.md 存在的意义，以及如何写 CONTRIBUTING.md
>
> [atom 项目的例子](https://github.com/atom/atom/blob/master/CONTRIBUTING.md)

[别在用 TODO 啦](https://goldin.io/blog/stop-using-todo)

> 用以下这些更有实际意义的词来替换 comment 中的 `TODO`
>
> - FIXME
> - HACK/OPTIMIZE
> - BUG
> - CHECKME/REVIEW
> - DOCME
> - TESTME
>
> vscode 插件 TODO tree、TODO highlight

[terser](https://github.com/terser/terser)

> 偶然打开这个库的 GitHub 看了下，才发现 `uglify-es` 已经[不维护了](https://github.com/mishoo/UglifyJS2/issues/3156#issuecomment-392943058)
>
> terser 也是现在主流使用的 js 压缩工具（es6+）

[将 base64 字符串文件转成 js 文件对象可以作为 form 的 input](https://stackoverflow.com/questions/35940290/how-to-convert-base64-string-to-javascript-file-object-like-as-from-file-input-f)

> 来自 stackoverflow，直接贴牛逼的代码吧 hh
>
> ```js
> function dataURLtoFile(dataurl, filename) {
>   var arr = dataurl.split(","),
>     mime = arr[0].match(/:(.*?);/)[1],
>     bstr = atob(arr[1]),
>     n = bstr.length,
>     u8arr = new Uint8Array(n);
>
>   while (n--) {
>     u8arr[n] = bstr.charCodeAt(n);
>   }
>
>   return new File([u8arr], filename, { type: mime });
> }
>
> //Usage example:
> var file = dataURLtoFile(
>   "data:text/plain;base64,aGVsbG8gd29ybGQ=",
>   "hello.txt"
> );
> console.log(file);
> ```

[Math and Front End](https://chenhuijing.com/blog/math-and-front-end/)

> 数学在前端的作用～在 web 开发过程中不会注意到的数学知识
>
> 数值：
>
> - `calc()`：自适应布局，[准确的字体大小自适应](https://www.madebymike.com.au/writing/precise-control-responsive-typography/)
>
>   ```css
>   // max:24 min: 12 maxVW:800 minVW:400
>   font-size: calc(12px + (24 - 12) * ((100vw - 400px) / (800 - 400)));
>   ```
>
> 几何：
>
> - `border-radius`：
>   - 可以是 `60px/30px` 其实可以接受两个参数，第一个是 horizontal 的值，第二个是 vertical 的值，以这两个值画的椭圆，就是这个 radius 了，原来可以这样！
>   - 同样，如果是给百分比数值，那他就分别是 width 和 height 的宽度，所以如果给 50%，就是完美的过渡圆角
> - 三角形：通常我们会用 border + transparent 去 hack [三角形](../02learning_notes/front_end_notes/css/CSS.md)，会需要计算高度

[why not use prettier](https://antfu.me/posts/why-not-prettier)

> 来自 antifu
> 自己的项目代码更会去选择 eslint 作为质量保证和 formatter 其他场景可以选择 prettier
> 安利了他自己的 eslint config
> 工具没有好坏之分，只是根据适用场景

[10 years of TS](https://devblogs.microsoft.com/typescript/ten-years-of-typescript/)

> typescript 的十年回顾
> 回顾加感谢的文章，读完能更加了解 ts 真正之于 js 的定位，很不错

[16 进制颜色的透明度数值](https://gist.github.com/lopspower/03fb1cc0ac9f32ef38f4)

> 很早就学到的东西，但一直没有记录，就顺便归档下
>
> 能够解决有透明度色彩的 hex 表达值，其实就是在 A 通道用 16 进制表达透明度百分比即可
>
> 直接看标准答案吧（转换百分比 -> 16 进制），然后 append 到字符串后面，记得补齐 2 位
>
> ```js
> const percentToHex = (p) => {
>   const percent = Math.max(0, Math.min(100, p)); // bound percent from 0 to 100
>   const intValue = Math.round((p / 100) * 255); // map percent to nearest integer (0 - 255)
>   const hexValue = intValue.toString(16); // get hexadecimal representation
>   return hexValue.padStart(2, "0").toUpperCase(); // format with leading 0 and upper case characters
> };
>
> console.log(percentToHex(0)); // 00
> console.log(percentToHex(50)); // 80
> console.log(percentToHex(80)); // CC
> console.log(percentToHex(100)); // FF
> ```
>
> 当然，很多地方（ide）都支持各种方式的转换，比较方便

[js container](https://tinyclouds.org/javascript_containers)

> 来自 deno 的文章，首先讲了大多数 server 的容器都是 Linux container 比如 docker，配置比较复杂，不高效，js 会将成为 universal scripting language 但这里指的是 browser 里的（node 设计的败笔就是加了很多非标准化的 api）
> deno deploy 已经在将 js 容器落地了，能够高效的提升业务逻辑效率
> 一些复杂的实现也可以用 wasm 来代替 js

[flexible.js?](https://juejin.cn/post/6844904029898670088)

> Recap:
>
> - rem: font size of the root element，相对于根元素（即 html 元素）font-size 计算值的倍数。
> - 移动端屏幕尺寸适配：1）替换 px 单位为 rem，2）根据屏幕尺寸动态调整 html 元素的 font-size 属性
>
> 目前业界已经有很多种方案（flexible.js，scss 结合 media-query，...）
>
> 这篇文章提出用 vw 直接做动态调整
>
> 1. 根据视觉稿宽度，750px == 100vw -> 1px = 0.133333vw -> 100px = 13.333333vw，所以设置 html 的 font-size 为 13.3333vw
> 2. 1rem == 1 unit('font-size') == 100px，所以视觉稿的 n 需要转换成 n/100 rem
> 3. 后者的单位转换可以用 postcss & pxToRem 来做
> 4. html 的 font-size 可以通过配置 + 构建脚本来做

[pdd 两年记](https://wingjay.bearblog.dev/review-in-pdd/)

> 同事之前推的文章。又完整的读了之后，感慨很多，pdd 的公司文化还是很不错的，也学到了很多技术方案的思路，也感叹移动端的这些事情还是做 native 比较有意思呀哈哈哈 XD。
>
> 长期价值 & 平常心。

[谷歌软件工程文化](https://www.bmpi.dev/dev/software-engineering-at-google/culture/)

> 也是正巧翻到自己 mac 的 books 里面有这本 'software engineering at Google'（全英版）最近好像很火的一本书，google 搜了一下发现 @madawei 也写过文章（SEO 做的真好）
>
> 也趁此机会准备开始抽空看一下这本。

[figma 构建 web 上的专业设计软件](https://www.figma.com/blog/building-a-professional-design-tool-on-the-web/)

> 文章是 figma 的创始人写的，讲述了想把专业设计软件做在 web 上的这个过程中遇到的种种困难（emscripten（WebAssembly）、渲染（webGL）、浏览器所提供的功能不足），同时强调了 figma 最重视的两个要素：Performance and quality

2022-12

[petite-vue](https://github.com/vuejs/petite-vue)

> 在 vue conf 2022 上听到尤大说把 vue1 的设计重新实现了一份 petite-vue，发现 demo 上一段 script：
>
> ```html
> <script src="https://unpkg.com/petite-vue" defer init></script>
>
> <!-- anywhere on the page -->
> <div v-scope="{ count: 0 }">
>   {{ count }}
>   <button @click="count++">inc</button>
> </div>
> ```
>
> 就是说 script 标签的 init 很不是理解，然后搜了一下在这个[回答](https://stackoverflow.com/questions/68238484/petite-vue-init-attribute-in-html-script-tag)里才知道，原来是 petite-vue 自己识别了这个 attr，很骚。

[lodash.get 类型推导](https://github.com/DefinitelyTyped/DefinitelyTyped/pull/62968/files)

> 来自公司里的一位大神，帮 lodash 的 get 新增了类型，太厉害了！可以详细看下这个 PR

[不用括号来调用函数](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)

> 脑洞还是很大的，主要原理还是基于模版字符串的标签模版
>
> ```ts
> function x() {
>   console.log(arguments);
> }
>
> x`a${123}`;
> // { '0': [ 'a', '' ], '1': 123 }
> ```
>
> 当一个函数被用作标签模版来调用之后，arguments（形参）是有一个规则的：
>
> 1. 第一个参数是根据模版字符串生成的一个数组，规则是分割占位符`${}`的字符串组合，包括最后一个空字符串
> 2. 后面的参数就是每个占位符了，可以无限放，他的值就是变量本身（注意了，什么都能放）
>
> 所以作者首先利用模版字符串可以喊（call）函数，干掉了括号 `()`，接着利用标签模版的调用规则，可以通过占位符放入各种想要的参数，但问题是第一个参数（分割字符串）通常是很多内置函数不需要的，所以得想办法 hack 跳过他。
>
> 于是用 `call`，因为第一个参数会绑定给 `this`，但是说不在 `window` 上？浏览器直接报错（Uncaught TypeError: Illegal invocation），但是 node 环境可以。
>
> ```js
> setTimeout.call`${console.log}${1000}${123}`;
> ```
>
> 所以再次 hack
>
> ```js
> [].sort.call`${alert}1337`;
> ```
>
> 文中还用到了 `Reflect.apply`

[小程序的同层渲染](https://developers.weixin.qq.com/community/develop/article/doc/000c4e433707c072c1793e56f5c813)

> “解决了原生组件的层级问题，同时也让原生组件有了更丰富的展示和交互的能力”
>
> 小程序是基于 webview 定制的渲染方案，如果要在 webview 之上扩展一些定制能力，比如说 video、map 组件，客户端渲染的层级是在 webview 之上的，所以要解决这个问题，让 webview 能扩展丰富的组件
>
> 文章讲到了两个端分别实现“同层渲染”的方案，核心思路就是通过 webview 内核的一些机制，让自定义组件渲染在 webview 的同一层（详细看文章就好了）

[2020 js13k 游戏 top10](https://github.blog/2020-10-11-top-ten-games-from-the-js13k-2020-competition/)

> [JS13K 竞赛](https://js13kgames.com/)：每年举办的，h5 游戏开发比赛，限制就是代码大小在 13kb 之内。
>
> 2020 年的主题是 _404_，其中我觉得最有意思的是 [track not found](https://github.blog/2020-10-11-top-ten-games-from-the-js13k-2020-competition/#track-not-found)，通过转变相机视角和 2D/3D，让火车轨道能够通行，很有意思。

[husky](https://typicode.github.io/husky/#/)

> 用了很久的 husky，来看看他的文档吧
>
> _You can use it to **lint your commit messages**, **run tests**, **lint code**, etc... when you commit or push. Husky supports [all Git hooks](https://git-scm.com/docs/githooks)._
>
> 可以在各个 git 环节（hook）增加指令

[数据大屏自适应方案](https://mp.weixin.qq.com/s/huzCTjMv8VcsTQ8_UjCv1g)

> 先上代码：
>
> ```jsx
> /*
> 	JS部分
> */
> //数据大屏自适应函数
> const handleScreenAuto = () => {
> const designDraftWidth = 1920;//设计稿的宽度
> const designDraftHeight = 960;//设计稿的高度
> //根据屏幕的变化适配的比例
> const scale = document.documentElement.clientWidth / document.documentElement.clientHeight < designDraftWidth / designDraftHeight ?
>      (document.documentElement.clientWidth / designDraftWidth) :
> (document.documentElement.clientHeight / designDraftHeight);
> //缩放比例
> (document.querySelector('#screen') as any).style.transform = `scale(${scale}) translate(-50%)`;
> }
>
> //React的生命周期 如果你是vue可以放到mountd或created中
> useEffect(() => {
> //初始化自适应  ----在刚显示的时候就开始适配一次
> handleScreenAuto();
> //绑定自适应函数   ---防止浏览器栏变化后不再适配
> window.onresize = () => handleScreenAuto();
> //退出大屏后自适应消失   ---这是react的组件销毁生命周期，如果你是vue则写在deleted中。最好在退出大屏的时候接触自适应
> return () => window.onresize = null;
> }, [])
>
> ```
>
> 不用 rem 的方案，纯靠 scale 来进行自适应，思路也比较简单：onresize 的时候通过计算宽高比和预设的设计稿宽高比进行比较，如果小于就选择宽作为缩放比例，大于就用高做缩放比，最后让容器 div `#screen` 进行 transform，这里为啥还要 `translate(-50%)` 呢，移动到中间？
>
> % 和 px 随便用，好评，不用担心单位计算
>
> 主要存在两个问题
>
> 1. **当缩放比例过大时候，字体会有一点点模糊，就一点点。**
> 2. **当缩放比例过大时候，事件热区会偏移。**

2023-1

[rimraf（node 的 rm 指令）](https://github.com/isaacs/rimraf)

> node 版的 `rm -rf`，只是内部仓库用到了，找来看看，用 node 应该就是要解决跨平台兼容性的问题（unix、linux、macos、windows）
>
> 看了下代码，其实就是用 node 的 fs 来操作，不走 shell 指令

[神人 Fabrice Ballard](https://zhuanlan.zhihu.com/p/386115058)

> 他的官网：https://bellard.org/
>
> QuickJS、FFmpeg 等一些非常牛逼有名的库的作者

[isInputPending](https://developer.chrome.com/articles/isinputpending/)

> Facebook(React) 为 chromium 提出的一个标准 API（文章是写在 2020，**chrome 87** 版本）
>
> 背景是解决 load fast or response fast 的问题：由于浏览器是单线程运作，加载页面（exec js 脚本）和响应事件（fire input 的一些回调），必然是阻塞的，需要将执行权交回给浏览器（常见的做法就是将任务分割，一个个 js block，执行完通过一次 settimeout 等宏/微任务，将线程执行权交还给浏览器），也就是 React 中的 schedular
>
> 有了 isInputPending 之后，可以如下代码更加优雅，也更加合理（相比手写时间片）
>
> ```js
> const DEADLINE = performance.now() + QUANTUM;
> const options = { includeContinuous: true }; // continuous events 比如 mousemove pointermove
> while (workQueue.length > 0) {
>   if (
>     navigator.scheduling.isInputPending(options) ||
>     performance.now() >= DEADLINE
>   ) {
>     // Yield if we have to handle an input event (any of them!), or we're out of time.
>     setTimeout(processWorkQueue);
>     return;
>   }
>   let job = workQueue.shift();
>   job.execute();
> }
> ```
>
> 一些 caution：
>
> - 小心使用（自己大概率也是用不到的）
> - 如果是在 iframe 中的交互 target 可能一直返回的是 false
> - 移动端比如安卓的 Chrome 不同的 page 会复用 event loop，所以 isInputPending 会不准确，需要结合 page visibility

[字体 otf 和 ttf](https://www.makeuseof.com/tag/otf-vs-ttf-fonts-one-better/)

> **True Type Font(.ttf)**
>
> - Apple 和微软一起创建的
> - 目标是为了在原生系统、打印机上渲染字体
> - 早期的跨平台字体文件格式
>
> **Open Type Font(.otf)**
>
> - Adobe 和微软
> - 包含 ttf 的特点
> - 文件存储可到达 65000 个字符（可以设计更多的字体）
> - 一些额外字体（Ligatures、Glyphs、small caps、alternate characters、old-style figures）可以直接在 otf 文件中共存（如果是 ttf 需要新增额外的字体文件）
>
> 哪个好？必然是 otf，优先考虑
>
> **_Web Open Font Format(WOFF)_**
>
> The Web Open Font Format is a little different in that it is a container for OTF and TTF, compressed and packaged with other information for use on the web.
>
> WOFF files are useful when a website wants to use a custom font that the user is unlikely to have stored on their machine.
>
> 可以通过 WOFF 文件来存放**压缩之后**的 ttf or otf、协议信息等
>
> Mozilla, Opera, and Microsoft 开发（2018），WOFF2 比 WOFF 压缩更好，大多数主流浏览器已经支持（**字体文件大小优化手段之一**）
>
> **关于 CSS 的 @font-face**
>
> 可以通过 src 属性的可选项 `format()` 告诉浏览器字体的格式，如果不支持 or 不合法，浏览器就不会下载这个资源
>
> 支持的类型[有这些](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src#font_formats)

[rollup dynamic import 插件 原理](https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars)

> 原文是一篇公司内部的文章，在迁移到 vite 的时候发现历史遗留的动态引入问题，于是调研了 rollup 的动态导入。主要内容其实就是对 github readme 的翻译，和源码分析
>
> - Rollup 插件构建时，动态引入（path 是动态的）是如何实现的，构建时不知道运行时的变量，通过一些特殊的手段。（[github](https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars)）
> - import( '../path/\${xx}.js' ) -> 会构造 glob path，然后编译所有的文件，再将代码转换成 switch/case 匹配
> - [源码](https://github.com/rollup/plugins/blob/master/packages/dynamic-import-vars/src/index.js)
> - 这个业务团队也用 [unplugin](https://github.com/unjs/unplugin) 开发了一个 vite 支持的插件

[babel 插件 按需引入](https://juejin.cn/post/7078527789388791821)

> [babel-plugin-import](https://github.com/umijs/babel-plugin-import)
>
> 一种按需引入的方法，核心就是通过 babel 改写 import 的路径：原本的路径改写成更加细粒度的组件文件路径
>
> 使用方法：
>
> - 直接在 `babelrc` 配置
>
>   ```json
>   {
>     "plugins": [["import", options]]
>   }
>   // options
>   {
>     "libraryName": "@material-ui/core",
>     "libraryDirectory": "components",  // default: lib
>     "camel2DashComponentName": false,  // default: true
>   }
>
>   // 例子
>   [
>     "import",
>     {
>       "libraryName": "@arco-design/web-react",
>       "libraryDirectory": "lib",
>       "camel2DashComponentName": false,
>       "style": true
>     },
>     "@arco-design/web-react"
>   ],
>   ```
>
> 最终编译结果（例子）
>
> ```js
> import { TimePicker } from "antd"
> ↓ ↓ ↓ ↓ ↓ ↓
> var _button = require('antd/lib/custom-time-picker');
> ```
>
> 扩展阅读：https://juejin.cn/post/7058964067100131365

[浅谈移动端开发技术](https://mp.weixin.qq.com/s?__biz=Mzg4MTYwMzY1Mw==&mid=2247496579&idx=1&sn=34dc5cc35bd62d20f6d6cf992928f579&source=41#wechat_redirect)

> 虽然是 21 年的文章，但是对于移动端开发的大概技术介绍都很全面，比较详细（在浏览器待了很久的 tab...）
>
> 主要是 Hybrid App
>
> - webkit
>   - 解析 HTML 和运行 JS 的核心
>   - 诞生于 safari，chromium 基于此，Chrome 浏览器
>   - IOS 中 JSCore
>     - JSVM
>     - JSContext
>     - JSValue 转换 JS 类型 -> OC 类型
> - RN
>   - JSI（JS 和 Native 通信）
>   - 新架构，解决了 JSB 通信消耗
> - Flutter
>   - Skia 自渲染
>   - Dart，放弃 Web 生态
>   - 类似浏览器渲染

[clay css](https://github.com/codeAdrian/clay.css)

> claymorphism styles 的 CSS 样式库，[demo site](https://codeadrian.github.io/clay.css/)
>
> claymorphism 中文翻译过来是粘土风格？inflated fluffy 3D elements
>
> 用法比较简单，安装好之后提供了预设的 class
>
> - class="clay"
>
> 为什么没有再做一个 UI Frame：（节选）相对来说比较新的设计理念，自由简单，不想维护 XD

[js is weird](https://jsisweird.com/)

> JS is weird!
>
> 这是一个做题网站，测试一下对 js 各种稀奇古怪的坑是否了解
>
> 做完题还会有讲解

[what makes GIT hard to use](https://www.highflux.io/blog/what-makes-git-hard-to-use)

> 使用 git 的体验和作者文中所说的一样感同身受，“常常感觉自己还是一个 git 新手”，git 对于大家日常使用的一些命令之外，还是比较难用的，主要原因：
>
> 1. 命令太多、太底层了，一些直觉上的操作，需要结合多个指令一起完成
> 2. 文件存在的版本太多了，作者觉得有 4 个，实际上只关心：当前自己编辑器中的，和远程仓库团队的版本
> 3. git 不太方便做实验，也就是缺少了很多 undo 的功能，以至于我们也不太敢尝试一些指令（也许代码就丢了）
>    1. 最好有撤销（undo）的能力
>    2. dry run 的选项，只输出执行结果，而非真正执行
>
> 最后作者推荐了一些工具，在 git 之上，让 git 的使用体验更佳

[codeball](https://codeball.ai/)

> 好家伙，AI based Code Review
>
> _我看 tt 有在使用？_
>
> 基于 github actions 触发 CR
>
> 支持的语言很多

[react 和 imgui 的区别](https://www.zhihu.com/question/39093254/answer/1351958747?utm_id=0)

> 渲染，立即模式，保留模式，的一些科普。
>
> react 这种 web 框架还是离渲染太远啦，dom 这层基本就封装掉底层渲染的东西了。

[设计模式为什么会流行](https://yinwang1.substack.com/p/846?continueFlag=da0095b31d2a28cf55236ccb31b4ab9f)

> 也没学过设计模式，还好没浪费这个时间哈哈。以及 yinwang 十年前的[吐槽](http://www.yinwang.org/blog-cn/2013/03/07/design-patterns)

[如何评价 qwik 框架](https://www.zhihu.com/question/467071621/answer/2835310168)

> 一个 22 年？出的新 SSR 框架，[官网](https://qwik.builder.io/)，应该也是 builder.io 主要的框架语言之一（好吧，qwik 的作者就是 builder.io 的 CTO...）
>
> 这篇文章讲的挺好，比较全面的说明了 CSR & SSR 目前的问题，以及 qwik 的 Resumability 思想
>
> 简单概述下现在传统 SSR 的性能问题
>
> - SSR 流程：服务端渲染好 HTML（reactDom.renderToString），发送到客户端，客户端需要再次 hydrate，执行一遍对应的 js 脚本，为的是给 html 元素绑定上交互需要的事件监听
> - 存在的问题（流程图来自文章）
>   - 在服务端下发 HTML 回到 CSR 之后，会进行 hydrate 的过程，需要下载解析全部的页面 JS，去恢复应用应有的状态（Recover 过程），所以消耗会非常大，真正等待交互的事件会延后（**TTI**，和 **FCP**）
>   - 当应用变得复杂，hydrate 过程会变得更长！
>
> **Resumability: 更加优雅的 hydartion 替代方案**
>
> - qwik 的作者认为 hydration 其实是多余的
> - 将必要的信息序列成 html 的一部分（减少 js 的解析）
> - 依赖于事件冒泡来拦截所有事件的全局事件处理程序
>
> ![img](_imgs/reading_list.assets/v2-bf7e87470c1035bbf73fcbd733aae5ae_1440w.webp)
>
> 具体细节可以看文章，讲的还是比较容易懂的

[SSR Islands 架构](https://juejin.cn/post/7155300194773860382)

> 依旧是前端 SSR 框架，作者也是字节员工
>
> - MPA 和 SPA 的取舍
> - Islands 架构：
>   - 也是解决 SSR 方案在全量 hydration 的过程导致页面 TTI 的折损
>   - 核心思路就是区分静态组件（无需任何交互的组件）将静态组件直接渲染成 HTML，用少量代码去做其他组件的 hydration（这些非静态组件就像是“岛屿”一样）
> - [Astro 框架](https://astro.build/)
> - 作者自己实现的 https://github.com/sanyuan0704/island.js
>   - 文章有整体流程，很不错
>   - 可以整体看一下源码
> - 这个架构框架无关（astro）

[solidjs 是 react 应该变成的样子](https://typeofnan.dev/solid-js-feels-like-what-i-always-wanted-react-to-be/)

> 一篇对 solidjs 的感受
>
> _If a linter knows when an effect (or callback, or memo) hook is missing a dependency, then why can’t the framework automatically detect dependencies and react to those changes?_ react 并不是真正 reactive
>
> BTW，solidjs [文档](https://docs.solidjs.com/)好全啊，unocss、部署到 vercel 都介绍了

[重新理解 web](https://zhuanlan.zhihu.com/p/581977751?utm_id=0)

> 又是一篇在字节的同学的文章，大佬真多啊。内部的飞书文档不能公开，全集是从 Web 切入到 Web XR。知乎是第一章「重新理解 Web」的摘录
>
> - Web Runtime（Web 三要素）：
>   - 传统浏览器/PWA/WebView/跨端容器
>   - 浏览器 -> 画框 -> 地址栏/收藏夹/...；内容/界面 -> 画布
>   - 标准化 Web 软件：分发、实现、运行三个维度的标准化
> - 前端技术（Web 三要素）
>   - 设计驱动开发/功能驱动开发
> - URL & Web 独特能力（Web 三要素）
>   - URL：资源的标识符「真名」
>   - 能力：分发、解绑、混搭、即用、动态、共创、跨平台、协作
>     - 安装 App 的心智 v.s. 随用随弃
> - 平台现状（新能力、to Dev、UI 框架、引擎、小程序/容器）
> - 总结
>   - 具备八大 web 独特能力的就是 Web

[husky 原理](https://juejin.cn/post/6879955438482227207)

> husky 是 lint 代码比较常用的工具，配合 `lint-staged` 在 git commit 之前进行 lint
>
> git hooks：
>
> - 在 git 操作前触发的自定义脚本（在 `.git/hooks` 目录）
>
> Husky 的作用：
>
> - 官方描述：Modern native Git hooks made easy
> - 通过配置共享 git hooks（团队协作）
>
> 原理：
>
> - 在 npm scripts 的 install 指令，执行 husky install（目前会需要指明：` "prepare"*:* "husky install"`）
> - 直接在 `.git/hooks` 下创建所有支持的 hooks
> - 内容都是执行 `husky.sh`，交给 husky 来执行 hook
> - 步骤：
>   - husky.sh 脚本获取 hook 名称
>   - 找到配置的 hook 对应的脚本
>   - 执行指令（node）
>
> 新版的 husky [不太一样](https://stackoverflow.com/questions/57297444/how-husky-works)，可以直接从 husky 源码入手：
>
> - husky install 会执行 `index.js`：
>   - 一系列判断（有没有 `.git`、git 状态...）
>   - 创建文件，包括 `husky.sh` 和 `hooks`
>   - **将 git hooksPath 指向 `.huksy` 路径，该目录下直接是各个 hooks**
>   - 每个 hooks 的开头会将 hook 交给 `husky.sh` 来执行
>     - 核心 ` sh -e "$0" "$@"` 是通过 `$0` 取到调用的脚本（hook）执行参数
>     - 下面就是需要执行的脚本，方便自己定义
>   - 无需再配置 package.json 等配置
>
> _`$0` 是 call 脚本的路径 or 指令，`$@` 是所有参数的特殊变量_

Tree shaking 问题排查指南（内部文档 docs/doccn8E1ldDct5uv1EEDQs8Ycwe）

> - Tree shaking 是在什么环节：LTO（Link Time Optimization）的时候，检查各个模块之间的引用依赖
> - 是什么：分析出模块中导出的被引用代码之外的代码是否有用，是否有副作用，删除这些代码
>   - _Tree shaking_ is a term commonly used in the JavaScript context for dead-code elimination. It relies on the [static structure](http://exploringjs.com/es6/ch_modules.html#static-module-structure) of ES2015 module syntax, i.e. `import` and `export`. The name and concept have been popularized by the ES2015 module bundler [rollup](https://github.com/rollup/rollup).
> - 每个打包工具之间的 tree shaking 算法比较固定
> - sideEffects：具体教程可以看 webpack 的 [doc](https://webpack.js.org/guides/tree-shaking/)，
>   - 值可以是 boolean，告诉打包工具模块里面所有的代码都是没有副作用的
>   - 也可以是 string[]，指定有副作用的代码
> - 误区：
>   - 包含副作用的代码，都不能配置 sideEffects false：就是要看这个副作用设计是给模块内部还是外部的，如 vue，虽然是有副作用，但是是给内部用的，所以可以配置为 true(see [side effects in vue](https://github.com/vuejs/vue/pull/8099))。
>   - Css 配置 sideEffects 为 false 来实现 tree shaking：直接 import 进来的 css 如果被认为是没有副作用就会被误 tree shaking 掉，导致直接引入的 css 不生效，跟着组件相关一起 shaking

[Webpack 设计理念](https://juejin.cn/post/7170852747749621791)

> 爽文，文章从核心思路到架构到 MVP 版代码实现，一气呵成

[Webpack HRM 解析](https://juejin.cn/post/7176963906844246074)

> 热更新是提升开发效率的强力工具之一
>
> 核心原理：
>
> - 「客户端」和「服务端」（webpack-dev-server）之间通过 ws 通信
> - 服务端 watch 代码变更（webpack compile 之后会有一个模块文件列表），推送更新消息给客户端，通知客户端去获取**最新的**模块变更
> - 服务端：每次编译都会生成一个 hash，通过 ws 发送给客户端
> - 客户端：
>   - 存 hash，比较上次 hash
>   - 如果不同，将自己的 hash 回传服务端（请求 hash.json 信息），让服务端比较出和最新代码之间的 diff
> - 服务端：
>   - 对比找出变更的模块 chunk 信息返回给客户端
> - 客户端：请求新的模块 js 文件，合并到自己的 modules，并且重新执行依赖这个模块的模块
>
> 这个图还挺不错的，摘录下
>
> ![image.png](_imgs/reading_list.assets/74519d751863471bb877a68bd3a4644d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

[前端的 Race Condition](https://juejin.cn/post/6938286092693176334)

> 常见的场景：登录/切换账户、切换 tab、搜索，请求返回时序不一致的问题（异步方法）
>
> 大部分语言是有资源锁/同步锁这种东西，然而 JS 是单线程的，异步渲染场景还是会有这个问题
>
> 解决方案：
>
> - 取消请求：比如 axios，基于 XMLHttpRequest 是可以取消的，详见 axios 的文档
> - 匹配请求：根据每次请求唯一 id 来匹配和执行，或者是匹配最后的请求
> - 取消 Promise：提前 reject，但实际的网络请求还是会发送出去，而不处理 response 了而已
> - rx.js

[beautiful gradients](https://www.joshwcomeau.com/css/make-beautiful-gradients/)

> 色彩是有趣的，更加好看的渐变色生成方式
>
> 传统的 CSS `line-gradient` 生成出来的渐变色中间那段会出现灰色区域，原因就是渐变插值方式用线性函数的时候，RGB 模型的色彩会趋于三通道接近的颜色（灰色）
>
> _`(128, 128, 128)` 灰度图！_
>
> 于是，考虑用其他的色彩模型就能得到更加好看的渐变，比如 HSI（色彩、颜色饱和度、亮度）。
>
> _HSL isn't concerned with how humans perceive colors, though; it's modeled after the raw physics, energy and wavelengths and such._
>
> 在 CSS 中目前还不能替换渐变的颜色模型，但是可以通过多个色彩去离散的逼近！思路有了
>
> 当然也有[工具](https://www.joshwcomeau.com/gradient-generator)能够 tweak 出自己喜欢的渐变效果，得到 CSS 代码，很棒！

[精度 react hooks](https://github.com/ascoders/weekly/blob/v2/079.%E7%B2%BE%E8%AF%BB%E3%80%8AReact%20Hooks%E3%80%8B.md)

> react hooks 是什么？
>
> **要解决的问题是状态共享**
>
> 状态共享可能描述的不恰当，称为**状态逻辑复用**会更恰当，因为只共享数据处理逻辑，不会共享数据本身。
>
> **“有状态的组件没有渲染，有渲染的组件没有状态”**：hooks 中应该只有逻辑，没有 UI
>
> 带有 hooks 的组件可以看作是纯组件，只不过 `state, setState` 是被当作 props 传给了 render，而触发 render 是其他的 effect
>
> P.S. redux 的 hooks 实现完全可以基于 `useContext` 和 `useReducer`（[源码](https://github.com/facebookarchive/redux-react-hook/blob/main/src/create.ts)）

[前端中的 Functional Reactive Programming](https://zhuanlan.zhihu.com/p/77687564)

> FRP: Functional Reactive Programming，其代表 RXJS 的函数式响应式编程
>
> 异步数据流
>
> 文章介绍了 RxJS 的核心概念：
>
> - Observable：异步数据流的抽象
> - Subscription：数据的消费方
> - Operators
> - Subject：multi-cast，（默认 unicast 的 Observable）共享数据源
>
> _但一旦领会其万物皆流、Observable => Pipeline => Subscription 的要义，随着异步逻辑复杂度的提升，例如表单交互、视频播放器、大型应用等等复杂场景，这种编程范式将会给你带来越来越高的性价比。_
>
> 至于是否选用 RxJS，结合自己的项目对于异步数据/操作的复杂度来判断吧！

[前端 2022 一览](https://vived.io/javascript-wrapped-2022-frontend-weekly-vol-119/)

> [中文翻译版](https://mp.weixin.qq.com/s/wC9Wq7FJ_sKg1I-z8AozCQ)
>
> 大多数都了解到了，摘录一些没了解到的/重要的
>
> - are types coming to JavaScript?：js 中引入类型说明的提案
>   - 卡在 stage 1，23 年可能会继续
>   - 能超过 ts 吗？感觉还很遥远
> - TS
>   - satisfies 关键字
>   - TS 的版本不是基于 Semantic Versioning
> - React 18
>   - concurrent mode：并发是关于对渲染进行排队、排定优先级以及添加中止正在进行的渲染的能力的。
>   - 新的 hook api：useTransition、useDeferredValue
> - SSR：
>   - Qwik、Astro island arch
> - Bun：
>   - Node 和 deno 的替代品，重在性能
> - Nodejs：
>   - 内置了 test 能力，无需引入 jest 之类的

[deepkit framework: high performance ts backend framework](https://github.com/deepkit/deepkit-framework)

> Mark 一下
>
> 2023.04.04 19:32:22 +0800
>
> 看了一下 [intro](https://deepkit.io/blog/introducing-deepkit-framework)，直呼太牛了。属于 Web 服务框架，最大化利用了 TS 的特性，简述下框架的几个特性：
>
> - Runtime Types：在 runtime 加入 type 信息会翻天覆地（对于 JS），deepkit 包含了很多好用的基础函数用来做运行时类型检查
> - Type Decorators：框架采用了 Branded Types，TS 自己的一种模式。可以将类型附加各种装饰信息，`type Username = string & MinLength<3> & MaxLength<23> & Alphanumeric;` 很直观有木有！而且很好的配合类型检查
> - Database Schemas：Deepkit ORM，支持所有 TS 类型
> - Router：HTTP API Routes 会自动根据所声明的类型做检查 params, body 等！
> - Dependency Injection：依赖注入问题，框架能够很好的解耦依赖（通过 implements interface，只要是满足类型的即可，而不是强耦合实现）（_In backend frameworks it was not possible until recently to write properly modular applications and libraries, because as soon as a dependency injection container is used with TypeScript, one is more or less forced to develop against implementations instead of abstractions._）
> - Configuration：应用的配置通常是单调无味的，在这里可以用一种很新的方法来写配置
> - High Performance：不仅是运行效率（ORM 效率很高，因为有自己的 js vm 包含了很多运行时的 JIT 优化），开发效率也很重要，在 Fully TS 的加持下，能够让项目长期保持高效的开发（感觉有点像 rust，能让所有人写的代码都符合高质量水平，而不会随着代码膨胀而变得难维护）
>
> 框架是如何工作的，有一个 type 编译器，将类型信息抽离成二进制码，会在 runtime 的时候通过一个小 vm 来执行，在 `{kind: ReflectionKind.string}` 中。细节在 [TypeScript Bytecode Interpreter / Runtime Types](https://github.com/microsoft/TypeScript/issues/47658) 非常长的文章。。之后再读读看吧，也不一定看得懂。
>
> 框架能力也非常的完善。也包括一个 debugger 工具？

[Minimize state](https://www.worldofbs.com/minimize-state/)

> _All Programming Philosophies Are About State_
>
> What this means is that there is no "one true way" to deal with state, and that each programming philosophy is useful and important in the correct domain. It also shows how important _minimizing_ state is.

[SQLite 文艺复兴](https://www.bmpi.dev/dev/renaissance-sqlite/)

> SQLite 的故事、架构
>
> 各个领域基于 SQLite 的创新
>
> _SQLite 为什么能在如此多领域有创新的项目出现？一方面得益于 SQLite 高质量的代码，近亿行的测试代码保证了其坚若磐石的可靠性，另一方面又得益其简单的架构，总共的实现源码也才 15 万行。_
>
> _随着 Serverless 及运行在 CDN 上的 Edge Computing 的流行，SQLite 这种轻量级的关系型数据库将会有更多的应用场景，也会有更多的创新出现。SQLite 也是一个非常适合学习的数据库，它的源码非常简单，可以很好的帮助你理解数据库的原理。_

[RESTful API 一把梭 post？](https://coolshell.cn/articles/22173.html)

> 挺有意思的背景：有人认为 api 全都用 post 一把梭，方便。
>
> 为什么要用不同的 HTTP 动词
>
> - **业务逻辑**。业务功能实现的代码，比如完成一个订单
> - **控制逻辑**。非功能性代码，用于程序/系统控制，比如多线程、分布式、协议、中间件等与用户需求无关
>
> 幂等
>
> - **缓存**。通过 CDN 或是网关对 API 进行缓存，很显然，我们要在查询`GET` 操作上建议缓存。
> - **流控**。你可以通过 HTTP 的动词进行更粒度的流控，比如：限制 API 的请用频率，在读操作上和写操作上应该是不一样的。
> - **路由**。比如：写请求路由到写服务上，读请求路由到读服务上。
> - **权限**。可以获得更细粒度的权限控制和审计。
> - **监控**。因为不同的方法的 API 的性能都不一样，所以，可以区分做性能分析。
> - **压测**。当你需要压力测试 API 时，如果没有动词的区分的话，我相信你的压力测试很难搞吧。
> - ...
>
> POST 更安全吗？
>
> - 不会，https 才会安全。`GET` 和 `POST` 的安全问题都一样的
>
> **你应该做的是为了“长期的早回家”，而不是“短期的早回家”**

2023.02.10 11:48:32

[wasm interface types](https://hacks.mozilla.org/2019/08/webassembly-interface-types/)

> 长文，讲述了 wasm 和 js 之间如何交换数据（wasm <-> js, js_1 -> wasm -> js_2）
>
> 太长了。。看了一半看不下去了

[zx 更方便的写脚本](https://github.com/google/zx)

> Bash is great, but when it comes to writing more complex scripts, many people prefer a more convenient programming language.
>
> 这个包是用来写更加复杂逻辑的 bash 脚本，用 node js！
>
> 官方代码示例用到了 top-level await，试了下 node16 已经支持了（虽然也搜到 v14.8 已经可以，但是试了下 v14.19 还是不行）
>
> 写完的 js 脚本需要用 `mjs` 后缀（node 用，如果是 `js` 后缀就不能用 top-level await 了）
>
> 开头需要 `#!/usr/bin/env zx` 让全局安装的 `zx` 来执行

[chatGPT 让谷歌掉千亿美元](https://coolshell.cn/articles/22398.html)

> chat GPT 现在很火（2023 年初），微软要基于此推出最新的搜索引擎并且结合进他们的全生态产品
>
> 1. **ChatGPT 不是基于事实，是基于语言模型的**，事实对他来说不重要，对他重要的是他能读懂你的问题，并按照一定的套路回答你的问题。
> 2. **因为是基于套路的回答，所以，他并不能保证内容是对的，他的目标是找到漂亮的精彩的套路**，于是，你会发现，他的内容组织能力和表述还不错，但是只要你认真玩上一段时间，你会发现，ChatGPT 那些表述的套路其实也比较平常一般。
>
> 因此，微软的 Bing + ChatGPT，成为了 Google 有史以来最大的挑战者

[泛型是如何实现的](https://www.bmpi.dev/dev/deep-in-program-language/how-to-implement-generics/)

> 看完之后，没怎么看太懂，不太了解编程语言的编译环节，底层的名次也很多
>
> generic programming 是什么：
>
> - _Generic programming is a style of computer programming in which algorithms are written in terms of types to-be-specified-later that are then instantiated when needed for specific types provided as parameters. This approach permits writing common functions or types that differ only in the set of types on which they operate when used, thus reducing duplication._
> - 上头这句话解释的很好，从编程的视角来抽象，将类型的确认后置，将类型作为参数，能够让我们写出更通用的方法/类型，减少代码重复度。
>
> 实现方式：
>
> - 类型擦除（Java）
> - 字典（Go）
>   - witness table（swift）
> - 单态化 Monomorfization
>   - 模版（C++）
>   - 腊印 GC shape stenciling（Go）

[个人技术栈](https://www.bmpi.dev/amp/dev/tech-stack-of-side-project/?__twitter_impression=true)

> mark 一下大佬的技术选择，虽然是 21 年的，但也有很多是值得参考的

[one year of excalidraw (2020)](https://blog.excalidraw.com/one-year-of-excalidraw/)

> 很厉害的白板绘图工具，自己也在用，很感兴趣
>
> 技术栈
>
> - 基于 [Rough.js](https://github.com/rough-stuff/rough) 绘制手绘风的图形
> - react
> - vercel
>
> [素材库](https://libraries.excalidraw.com/?theme=light&sort=default)
>
> [npm package](https://www.npmjs.com/package/@excalidraw/excalidraw) 可以作为项目中的组件
>
> 以及用户很多精彩的设计！

[2022 大前端总结](https://mp.weixin.qq.com/s/AU-d819I-Zo9sQOdbbU3Iw)

> 文章快速的回顾了 21 世纪以来的前端技术发展，点出了 09 年 node 的出现引发了前端自我技术迭代，从而直接带来一波技术爆炸，13 年 angular 和 backbone 等插件对后来 mvvm 框架的启发，可以说 13-19 年的前端技术增长（以及薪资增长）是极为惊人的，这也是前端的“黄金时期”。此外，作者也分阶段解读了“全栈”的发展，从 ror 时代的“全干”，到仅兼顾 bff 等 API 胶水层开发，再到低码全栈，大家可以看下文章中提到的 retool 官网视频，就能明白目前低码发展到什么程度以及为何如此受资本追捧了：https://retool.com/（很震撼）
>
> [Pake](https://github.com/tw93/Pake) 原来是基于 tauri 封装的，用法简单，很厉害
>
> [Rust 是前端基建的未来](https://github.com/i5ting/learn-rust-for-fe)
>
> _1）拥抱变化，积极转型全栈。大部分的只能这样选择_
>
> _2）主动出击，做好 bff，去分一块服务端的业务。_
>
> 说实话看完这篇文章的第一感觉就是迷茫，个人认为这两年的前端关键字是“DX”，不管是框架、构建，都在往性能、体验上做文章

[volar a new beginning](https://blog.vuejs.org/posts/volar-a-new-beginning.html)

> Volar，Vue 的官方 VSCode 插件
>
> highlight：_As an example, ByteDance's Lynx team, an early adopter of Volar.js, shipped a whole set of language tools supporting their in-house framework with two weeks of work from a single developer. That would have taken months if it were built from scratch even with a team._
>
> Volar 整体架构的变化（拆分 volar.js）；目前的 Team；
>
> 后续的规划：
>
> - [Monaco's](https://github.com/microsoft/monaco-editor) support(The Monaco Editor is the code editor that powers [VS Code](https://github.com/microsoft/vscode).)
> - 支持其他 ide
> - 基于 bun 的 Language Server，目前 bun 没有完全兼容 Node Api 的 LSP servers
> - Monoserver：看意思是说现在的 LS 是与 ts language server 分开的，但是大多数框架语言都支持 ts，合并之后能够减少大量的开销
> - ...

[CSS Custom Highlight API](https://juejin.cn/post/7199438741533376573)

> _尚未实践，先 mark_
>
> Chrome 105 以上加入，能够通过不改变 dom 结构的情况下，为文本增加自定义高亮
>
> 使用场景：
>
> - 花里胡哨的文字颜色变换效果（🌈）
> - 自定义的搜索文本高亮
>
> 具体步骤（js）：
>
> 1. 创建选区，`new Range`
> 2. 创建高亮，`new Highlight`
> 3. 注册高亮，`CSS.highlights.set`
> 4. 自定义样式，`::highlight()`（CSS）
>
> 相比传统使用标签的方式而已，有很多优点
>
> 1. 使用场景更广泛，很多情况下不能修改`dom`或者成本极大
> 2. **性能更好，避免了操作`dom`带来的额外开销，在`dom`较多情况下性能差异至少`100`倍**
> 3. 几乎没有副作用，能有效减少`dom`变化引起的其他影响，比如光标选区的处理

[让 history 更好用的 tips](https://cyb.org.uk/2021/05/03/bash-productivity.html)

> 使用命令行的时候，经常会反复的敲出之前的命令，这篇文章讲了一些 tips，让我们更高效的使用 history
>
> 1. Use HISTIGNORE to remove pointless commands from history
>    1. 目标：减少一些无用的指令出现在 history 中（无用：常用的，不需要在 history 里面找）
>    2. 例子：`export HISTIGNORE='pwd:exit:fg:bg:top:clear:history:ls:uptime:df'`
> 2. Recalling commands effectively
>    1. `!!` recalls the previous line，加上 `:p` 可以仅展示而不立即执行（等同于按上箭头）
>    2. `!ping` 可以展示上一条 `ping` 命令的历史
> 3. Using parameters from the previous line with `!$` and `!*`
>    1. 上一条指令参数的简写变量
>    2. 例子：
>
> ```
> $ rm /var/log/httpd/access.log /var/log/httpd/error.log
> $ touch !*
> touch /var/log/httpd/access.log /var/log/httpd/error.log
> ```
>
> 4. Use readline for partial history search
>    1. `ssh <up arrow>` 提示上一条执行 ssh 的命令参数（warp 支持）
>
> 总结下：很实用，现在用的 warp 也有很多好用的提效功能，包括智能命令搜索 `⌃ + ~`

[发现大佬 postcss/browserlist/nanoid/size-limit 等的作者](https://github.com/ai)

> https://github.com/ai/size-limit 这个感觉很有意思，测试你的 js 项目在各个环节的性能

[experimenting-a-new-syntax-to-write-svg](https://yuanchuan.dev/experimenting-a-new-syntax-to-write-svg)

> css-doodle 的作者的 blog，用 CSS 的写法来写 svg，原因是 svg 写起来真的很费劲（两个维度上的复杂性：tag 和 attr）
>
> 于是用 css 的写法来写 svg，最后再转码成 svg
>
> BTW：[css-doodle](https://css-doodle.com/) 是一个很有意思，很强的项目：web-component + CSS 自定义语法来绘制图案，太强了

[从 JS VM 看 a=-x 的优化方式](https://twitter.com/mhevery/status/1626002464469323777)

> 来自一条 twitter thread（builderio 的 CEO。。）
>
> `a = 0 - x` 比 `a = -x` 性能快 3-10x
>
> JS 有两种存 number 的方式
>
> - Integers：_Two's complement_ 翻译过来叫“二补”？**不能有 `-0`**，浮点数可以
> - Floats(IEEE 754)
> - number 数组存的时候如果有混合类型（int 和 float），访问效率会慢，如果只有 int 访问效率高（VM 会创建更快的纯整数数组）
> - 访问数组必须是 integer，所以转换 float 到 int 也会有开销
>
> 可以看 [demo](https://perf.builder.io/?q=eyJpZCI6Inh0a3l0czhvbDY5IiwidGl0bGUiOiJGaW5kaW5nIG51bWJlcnMgaW4gYW4gYXJyYXkiLCJiZWZvcmUiOiJjb25zdCBkYXRhID0gWzAsIDFdO1xuY29uc3QgZGF0YUludCA9IGRhdGEubWFwKHY9PjAtdik7XG5jb25zdCBkYXRhTWl4ID0gZGF0YS5tYXAodj0%2BLXYpO1xuXG5jb25zdCBsZW5ndGggPSAxMDA7XG5jb25zdCBpZHhJbnQgPSBbXTtcbmNvbnN0IGlkeE1peCA9IFtdO1xuZm9yKGxldCBpPTA7IGk8bGVuZ3RoOyBpKyspIHtcbiAgaWR4SW50LnB1c2goaSUyKTtcbiAgaWR4TWl4LnB1c2goLShpJTIpKTtcbn1cbiIsInRlc3RzIjpbeyJuYW1lIjoiSW5kZXggYXJyYXkgd2l0aCBJbnQiLCJjb2RlIjoibGV0IHN1bSA9IDA7XG5mb3IobGV0IGk9MDsgaTxsZW5ndGg7IGkrKykge1xuICBzdW0gKz0gZGF0YUludFtpZHhJbnRbaV1dO1xufSIsInJ1bnMiOltdLCJvcHMiOjEyMDI3NH0seyJuYW1lIjoiSW5kZXggYXJyYXkgd2l0aCBGbG9hdCIsImNvZGUiOiJsZXQgc3VtID0gMDtcbmZvcihsZXQgaT0wOyBpPGxlbmd0aDsgaSsrKSB7XG4gIHN1bSArPSBkYXRhTWl4W2lkeE1peFtpXV07XG59IiwicnVucyI6W10sIm9wcyI6MzYxMDJ9XSwidXBkYXRlZCI6IjIwMjMtMDItMjFUMDU6MDU6NDYuMjg3WiJ9)，总结下，也算是比较 tricky 的手段了，个人感觉使用场景比较有限，大部分时候不太能明确区分一个 number 变量最后是 int 还是 float XD，知道 -0 是会转成 float 就行了，`0 - 0` 还是 int。

[JS VM 看对象属性的访问以及如何优化的](https://twitter.com/mhevery/status/1622499293440663553)

> 同上，依旧是 thread(Understanding monomorphism can improve your JavaScript performance 60x.)
>
> “单态性”提速，结论：这里是指保持对象的单态，不要随意让某个属性消失/出现（比如声明了 `o = {}` 然后给属性赋值，破坏了单态性）
>
> 原理：
>
> - CPU JSVM 不知道啥是对象，存储方式使用数组来存储的
> - 第一位是 ClassShape（这个对象长啥样，有哪些属性）
> - 后面 ...rest 就是属性对应的值
> - JS 访问属性的时候，VM 实际上是访问那个对象数组，通过 ClassShape 来寻找属性所在的下标（寻址取值）
> - 当然 VM 会对这个寻址过程做缓存来优化：如果对象的 ClassShape 之前已经访问过，就知道这个属性位置在哪，即可缓存。这里的缓存是 `inline-cache`
>
> ```js
> // JS code
> const u1 = builder.url;
> // VM
> const u1 = vmBuilder[vmBuilder[0].indexOf("name") + 1];
> ```
>
> 还有值得注意的点是：inline cache 数量是 4，所以很快，之后的 indexOf（VM 实现会更加复杂），但是有 megamorphic-cache，chrome 是 1024 个 entry，所以也比较稳定。
>
> _`indexOf` implementation is a bit more complicated. The actual function has something called megamorphic cache which in chrome is 1024 entries._
>
> 最后就是优化手段：
>
> ```js
> // slower
> const obj = {};
> obj.firstName = "123"; // 寻址过程中多次的 ClassShape 切换
> obj.secondName = "1234";
> // faster
> const obj = {
>   firstName: undefined,
>   secondName: undefined,
> };
> obj.firstName = "123"; // ClassShape 能被一直缓存
> obj.secondName = "1234";
> ```

[天猪的文章：主题色算法](https://xcoder.in/2014/09/17/theme-color-extract/)

> 14 年的，算法是用八叉树、最小差值（先用八叉树过滤出颜色）
>
> 最后 nodejs 包，包含了 c++ 的部分（算法计算）
>
> 主题色提取的应用场景还挺多，基本都是自定义图片的背景/装饰之类的，为了和主题更加和谐（比如苹果现在 IOS16 桌面播放器的背景色也是主题色算的）

[利用 JS Map 实现 O(1) 的 LRU Cache](https://gist.github.com/dherges/86012049be7b1263b2e594134ff5816a?permalink_comment_id=4238757)

> 来自一条 tt，不过直接放 gist 代码吧。
>
> 代码比较简单清晰，主要是需要了解 JS Map 实际上是维护了两个数组，通过数组来寻找值的
>
> O(1) ：Map 取 key，至于为什么，后面讲到的 hash code
>
> LRU：如果是 recent，就是第一个，如果不是，就重新 set 到 Map 中
>
> 解析版：（代码里面还有 非 class 版和非继承版的，按需～）
>
> - 注意一个点是 map.keys() 返回的是一个迭代器（按照插入的 key 顺序），next() 获取的是下一个 key，这里为什么要删除第一个呢
>
> ```typescript
> // simple O(1) LRU cache least recent used
> // prettier-ignore
> class LruCache< T > extends Map<string, T> {
>   constructor(private maxSize = 20, entries?: [[string, T]]) {
>     super(entries);
>   }
>   get(key: string) {
>     const hasKey = this.has(key);
>     if (!hasKey) {
>       return;
>     }
>     const value = super.get(key);
>     // Reinsert to mark as most recently used??
>     this.delete(key);
>     super.set(key, value!);
>     return value;
>   }
> 
>   set(key: string, value: T) {
>     if (this.size >= this.maxSize) {
>       // max size for LRU
>       // Delete the least recently used key??
>       this.delete(this.keys().next().value);
>     }
> 
>     return super.set(key, value);
>   }
> }
> ```

[JS Map 的魔力](https://www.builder.io/blog/maps)

> 还是 builder.io 的 blog，收集了之前提到的一些 TT Thread
>
> 提到了 JS VM 如何优化 JS 对象 by assuming their [shape](https://mathiasbynens.be/notes/shapes-ics)（以后研究）
>
> Another great article is [What’s up with monomorphism](https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html)（解释了为什么 JS 对象不太适合像 hashmap 那样使用频繁的增删 keys）
>
> 还是在说 Map 比 Object 更好用的场景和优势：
>
> - 性能更好：属性（key/value）删除/增加操作性能大幅优于 object
>
> - object 的 Built-in keys 问题（会和内置 key 冲突，即使看起来是空对象）
>
> - 迭代对象的操作很糟糕，Map 更好，直接用 `values()` `keys()` 或者本身迭代即可
>
> - key 的顺序，Map 是有序记录加入的顺序的，Object 是乱序
>
> - 复制，可以直接 `new Map(map)` or 通过 entries 和 object 转化 or structuredClone
>
>   - ```typescript
>     const makeMap = <V = unknown>(obj: Record<string, V>) =>
>       new Map<string, V>(Object.entries(obj));
>     ```
>
> - key 的类型，可以是所有类型，比如想记录对象的一些 meta 信息。当然还有 WeakMap（内存占用问题）
>
> 什么时候用 Map or Object
>
> - Object：有固定的结构，用对象能过更快的读写
> - Map：频繁的 key 操作
>
> 这篇文章还提到了 JSON.stringify/parse...他们的第二个参数用来转化数据，可以将非对象的变量转成对象，为了 JSON，反之也是可以从 JSON 获取想要的类型
>
> ```js
> function replacer(key, value) {
>   if (value instanceof Map) {
>     return { __type: "Map", value: Object.fromEntries(value) };
>   }
>   if (value instanceof Set) {
>     return { __type: "Set", value: Array.from(value) };
>   }
>   return value;
> }
>
> function reviver(key, value) {
>   if (value?.__type === "Set") {
>     return new Set(value.value);
>   }
>   if (value?.__type === "Map") {
>     return new Map(Object.entries(value.value));
>   }
>   return value;
> }
>
> const obj = { set: new Set([1, 2]), map: new Map([["key", "value"]]) };
> const str = JSON.stringify(obj, replacer);
> const newObj = JSON.parse(str, reviver);
> // { set: new Set([1, 2]), map: new Map([['key', 'value']]) }
> ```

[v8 hash code](https://v8.dev/blog/hash-code)

> v8 官方 blog
>
> ES 2015 引入了一些新的数据结构比如 Map Set WeakSet WeakMap，这些底层其实都是用 hash table 实现的。这篇博文介绍了
>
> - Hash Code 是什么：
>   - hash function 将一个 key 映射成 hash table 中的一个位置（下标、...）
>   - hash code 就是 hash function 执行之后的结果
>   - V8 中 hash code 就是一个随机的数字，独立于对象，必须存起来（每个对象可以有一个）
>   - 是对象一个类似 `Symbol` 的 privite key，但是不会暴露给用户侧的 js
>   - 并且这个 hash code 是当对象需要它时才会计算和存储，不用到的时候可以节省空间
>   - V8 优化查找这个 hash code 的方式是一样的用 monomorphic IC lookups，inline-cache!（当对象有相同的 hidden class），但是大多数情况都不能满足，就会 megamorphic IC lookups（可以理解是全局的 cache？比较慢了）
>   - 访问这个 prvite symbol 也会触发 hidden class transition
> - JS Object 背后如何存数据的
>   - one word for storing a pointer to the **elements backing store**, and another word for storing a pointer to the **properties backing store**.
>     - elements：就是数组的元素，在内部也是类似数组的结构
>     - properties：属性值，string or symbols
> - 如何存(hide) hash code
>   - 存在 elements，因为数组是不定长，总会浪费空间
>   - 所以会存在 properties 的空间：数组 or 字典
>     - 空。无 properties
>     - array（最大限制 1022 个，超过后 V8 会转成 dictionary 存）
>     - dictionary（会新开辟一个空间，但是问题不大）
> - 三种方式存储之后，得到的结果是：hash code 的 lookup 不需要和 js 对象属性访问那么复杂了！
>
> 小结：
>
> - Map 为什么能比对象取 key 更快？就是因为读取的是元素的 hash code，hash code 又通过上述存储方式可以比常规属性访问快速很多！
> - 个人假想：`Map.set(key, value)` 的时候，是先获取 key 的 hash code，将 value 存在 hash table，get 取的时候也直接取 key 的 hash code（很快），所以 Map 的存取操作非常快 O(1)。任何字面量/常量的 hash code 应该也是一样的？或者说存储的地方也是同一个，保证 `getHash(true) === 'xxxx'`
> - 个人假想：Map 的 key 为啥是有序的，内部通过数组来存的 key 的引用？Remained Problem

[rescript](https://rescript-lang.org/docs/manual/latest/introduction)

> Rescript 另一种 JS 方言？知乎看到是国内大佬开始搞的，编译到 JS，更好的 type 系统
>
> 和 TS 的区别：
>
> - TS 目标在于 cover JS 的全部特性；**Rescript covers only a curated subset of JavaScript**.
> - TS 的类型系统有很多陷阱，Res 没有；
> - Res 的性能非常快
> - **Migrating to TypeScript is done "breadth-first,"**，**migrating to ReScript is done "depth-first."**
>   - 切换到 ts 其实只要改个文件后缀就行了，很轻易，但是会泄漏很多 js 无类型的很多漏洞。无法衡量安全性
>   - Rescript 限制了只能写纯 res or 纯 js code
>
> 更多：
>
> - **比 JS 更快**
>   - 编译器编译到的 JS 代码会做很多的优化，针对 VM 的，比如 Just-In-Time optimizations (hidden classes, inline caching, avoiding deopts, etc).
>   - 也许通过这样能学会如何写更高效的 JS
> - High Quality Dead Code Elimination
> - Tiny JS Output
> - Readable Output & Great Interop（互通性）
> - Preservation of Code Structure
>
> [和 React 的关系，提供了非常好的 bindings](https://rescript-lang.org/docs/react/latest/introduction)
>
> [编译器](https://github.com/rescript-lang/rescript-compiler)是用 OCaml 写的。浅了解下。。

[tnpm rapid 模式比 pnpm 快 10s](https://zhuanlan.zhihu.com/p/455809528)

> 还是关于包管理器的
>
> [最终更快的 npminstall 已经开源了](https://github.com/cnpm/npminstall)
>
> 介绍了 npm 下载一个包经历的过程，为什么慢
>
> tnpm 和 cnpm 是什么？
>
> - tnpm 是 taobao npm 私有源
> - cnpm 是中国 NPM 公共镜像站
>
> ![img](https://pic1.zhimg.com/80/v2-fffade5e024f3bd1e6095694ec78b0cc_1440w.png)
>
> 如何优化：比较深入了，浅浅了解
>
> - 网络 IO
> - FUSE 文件系统
> - 文件 IO
> - ...
>
> 文章的最后，摘录下：
>
> **cnpm 和 tnpm 并不是另一个包管理器的竞品，我们一直专注的领域是企业的私有化 Registry 服务。而 npmfs 在设计之初就不希望绑定特定的包管理器，我们未来将开源出去，任何包管理器都可以尝试集成该能力。**
>
> 同时我们也呼吁：**前端的包管理的规范化**：
>
> - 有类似 ECMA 之类的标准，来规范各个包管理器的行为。
> - 有类似 Test 262 的测试用例规范。
> - 处于薛定谔阶段的 ESM 和 CommonJS 规范的加速演进。
> - 前端 和 Node.js 不同场景依赖的差异性的混乱局面得到解决。
>
> 关于它的[讨论](https://www.zhihu.com/question/515760375)
>
> - pnpm、vercel 的大佬都评价了

[ts-reset](https://github.com/total-typescript/ts-reset)

> like css reset(reset.css)
>
> 这个 ts 库也为一些平时比较痛的 ts 问题增加了一些妙药
>
> 同时对于一些问题也没有加更好的类型：
>
> - Object.keys/entries：因为 ts 是 duck deducing，在 type 之外的属性其实也是合法的，不能仅返回 `keyof T`
> - Generics for `JSON.parse`, `Response.json` etc

【Archived to [nanostores](../02learning_notes/front_end_notes/state/nanostores.md)】[状态管理 nanostores](https://github.com/nanostores/nanostores)

> 细看了源码，写的还是很有意思的，一个 atom store 完成了基础类型变量的状态系统，衍生出 map 处理对象类型，先写的 js 再加的 ts 类型，感觉写起来会方便很多（不用顾及写代码时候的类型了）
>
> 支持的场景也比较丰富，computed，action，mapTemplate（可以简化很多相同类型的状态所需的代码）
>
> 整体的生态还是比较完善的，支持很多现代框架，看了 [nanostores/react](https://github.com/nanostores/react) 的代码，简单的结合 [`useSyncExternalStore`](https://beta.reactjs.org/reference/react/useSyncExternalStore#usage) 完成的，很棒，又学了一个 hook。
>
> 代码还是比较简洁和易懂的，也不多，从 `atom` 开始 `map`，然后到 `task` `action` `lifecycle`...不是很费力
>
> BTW 这个[作者](https://github.com/ai)非常牛牛牛啊，The creator of Autoprefixer, [@postcss](https://github.com/postcss), [@browserslist](https://github.com/browserslist), and [@logux](https://github.com/logux)

[Monorepo tools compare](https://byteofdev.com/posts/lerna-vs-turbopack-rush/)

> 比较了 lerna turbopack rush 这三个 monorepo 工具的 setup performance 和 features。

[runs user-provided code into a Web Worker](https://github.com/slashd-analytics/run)

> 看了下源码，非常简洁，能够在 worker 中执行自定义代码（这个包的背景是为了他们的 low code 项目，执行不同作者的 code）
>
> 能够安全的执行一些非信任的代码（as string）（worker 有很多限制，不能读 dom 之类的）
>
> 思路：
>
> - 组合上下文信息，将代码片段塞入预先写好的 worker 线程运行的 js 代码中
> - worker 执行的结果用 postMessage 抛出给主线程，处理 error（闭包了 promise 的 resolve 和 reject）
> - 将 worker 代码构造成 Blob 并且 createObjectURL 实例化 Worker

[前端中的 pipeline](https://zhuanlan.zhihu.com/p/28561932)

> _计算机领域的 Pipeline 通常认为起源于 Unix。最初 Douglas Mcllroy 发现很多时候人们会将 shell 命令的输出传递给另外一个 shell 命令，因此就提出了 Pipeline 这一概念。后来同在贝尔实验室的大牛 Ken Thompson 在 1973 年将其实现，并使用 | 作为 pipe 的语法符号_
>
> 优雅的 pipeline，很常见，比如 express/koa 的中间件、Node 的 stream pipeline、gulp 采用流水线的配置形式、Browserify 用 pipeline 的形式来处理复杂的打包任务、promise pipeline、ramdajs、rxjs

[Lerna 运行机制](https://mp.weixin.qq.com/s/cTHhYZK3UMKfWnHpSoWurg)

> 首次读于：20220524
>
> 执行 command 的那块源码分析吧，挺深的，代码真骚，看懂一半吧，需要真的 clone 看下源码
>
> 2023.03.03 更新，完全忘了内容，有空再看看

[HTTP 链接池](https://www.cnblogs.com/xrq730/p/10963689.html)

>

day.js

> JS 时间库用 day.js

[lerna to Nrwl](https://github.com/lerna/lerna/issues/3121)

> lerna 的维护者退休了，交给 nx 的公司 nrwl 来维护

[JS third age](https://www.swyx.io/js-third-age)

> In summary: Third Age JS tools will be
>
> - Faster
> - ESM first
> - Collapsed Layers (One thing doing many things well instead of many things doing one thing well)
> - Typesafe-er (built with a strongly typed language at core, and supporting TS in user code with zero config)
> - Secure-er (from dependency attacks, or lax permissions)
> - Polyglot
> - Neo-Isomorphic (recognizing that much, if not most, JS should run first at buildtime or on server-side before ever reaching the client)
>
> JS 会死吗？“JS could be “the universal virtual machine”, but [told me once that](https://twitter.com/BrendanEich/status/1001307081725562882?s=20) WASM now is the ultimate fulfillment of that idea.”
>
> 未来会是 WASM 吗

[移动端页面键盘无法自动拉起](https://juejin.cn/post/6844903504230744077)

> 踩坑，发现无论在 IOS 还是 Android 的 webview 都无法主动通过 `input.focus()` 来拉起键盘，只能通过 native 配合实现了 XD
>
> and [这篇](https://www.zhihu.com/question/28905353)

[pm2 nodejs process manager](https://github.com/Unitech/pm2)

> node application 进程管理，功能很丰富，先马后用
>
> with a built-in load balancer. It allows you to keep applications alive forever, to reload them without downtime and to facilitate common system admin tasks.

[Turbopack 从 go 迁移到 rust](https://vercel.com/blog/turborepo-migration-go-rust)

> Vercel 将构建工具从 go 迁移到 rust 的一些背景和原因
>
> go 更适合处理复杂网络中心的事物
>
> Go favors simplicity over expressiveness，runtime-error 会很多，但是对于用户需要 install 的软件来说，错误会被放大
>
> 更加追求 up-front correctness 和 go 所专注的方向 mismatch 了
>
> Rust 的语言在复杂度和正确性之间做了 tradeoff（更加正确，但是更复杂）
>
> rust 的生态好，有很多库是底层用 C/C++，上层暴露 Rust API
>
> _Happier developers deliver better software. Your brain is [better at complex problem-solving](https://www.psychologicalscience.org/news/releases/a-positive-mood-allows-your-brain-to-think-more-creatively.html) when it's happy._ 哈哈

[why use border-box](https://www.quora.com/What-does-box-sizing-border-box-do-What-are-its-advantages)

> 突然好奇我们实际开发中 css 的 `box-sizing` 都是统一使用 `border-box`（reset.css 之类），于是 google 了一下
>
> 简单来说最大的方便之处就在于不用去额外计算 content + padding = 总宽度的问题了，确实很方便！

2023.03.14 18:45:52

[Tomohoko sakamoto algorithm 求星期几](https://www.geeksforgeeks.org/tomohiko-sakamotos-algorithm-finding-day-week/)

> 最牛的求一个日期是星期几的算法：先看代码
>
> ```c++
> int day_of_the_week(int y, int m, int d)
> {
>     int t[] = { 0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4 };
>     if (m < 3)
>         y -= 1;
>
>     return ((y + y / 4 - y / 100 + y / 400 + t[m - 1] + d) % 7);
> }
> // day_of_the_week(2023, 3, 14);
> ```
>
> 很迷幻对吧，来看下[解释](https://www.quora.com/How-does-Tomohiko-Sakamotos-Algorithm-work)：
>
> 1. 首先需要知道日期的源头，也就是公历（Gregorian calendar）公元（AD）的 1.1 是星期几，星期一
> 2. 先不看闰年，一月 31 天（7\*4+3），所以 2.1 会比 1.1 的星期多 3 天，3.1 比 1.1 多 3 天，以此类推得到数组 `t[] = {0, 3, 3, 6, 1, 4, 6, 2, 5, 0, 3, 5}`
> 3. 每一年是 365 = 52 \* 7 + 1，所以每一年都会比前一年多 1，我们需要加上 y
> 4. 再看闰年（leap years）问题：
>    1. 每 4 年一次闰年，会多一天，每 100 年又不会多一天，每 400 年又多一天
>       1. 好吧每 100 年不算闰年，但每 400 年算闰年，[常识问题](https://www.quora.com/Why-do-we-skip-a-leap-year-every-100-years)：一年真实 365.24 天，所以每四年多一天（leap year）来修正（平均每年 365.25 天），于是每年就又多 0.01 天，所以每 100 年的时候，还得归还这一天，所以每 100 年的闰年就还是 365 天，但是每 4 \* 100 年，又遇到了 4 年问题，所以还得算是闰年
>       2. _咱就是说自己也活不过百年，谁知道这事呢哈哈哈_
>    2. 所以需要加上闰日：`+ y / 4 - y / 100 + y / 400`（都是整除）
> 5. 例外：因为闰日（leap day）不是 1 月 0 日（d 不等于 0，如果是 0 就无脑加 d 就行了），而是 2 月 29 日，所以当年不能被算在里面（按照 4 已经算了一个闰日了），如果是 1、2 月，要将 y 减 1，y/4 这些值按照上一年算，不会多算一天（这是一种非常简洁的办法，牺牲了可读性。。）
>    1. 这样还有个小问题，就是把非闰年也当作闰年来做了，这样 2.28 - 3.1 中间空了一天，所以作者把 2 月之后的每一天都减少了 1，这样来弥补 gap，很聪明。。
>    2. 所以现在的数组：`t[] now becomes {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4}`
>
> 最终就是以上的代码，其实还需要加上一个基数（起始的星期几，是 1，但是 d 已经是从 1 开始计数了，也就不用加了），核心思路就是计算出距离公元 1.1 的偏差，通过周期来简化。
>
> 解析完了，感觉很费解。。很烧脑哈哈，自己太笨了。
>
> [c++ playground](https://www.sololearn.com/compiler-playground/cpp)

[knip 检测出项目中未用到的文件/导出](https://github.com/webpro/knip)

> 很精致的项目，功能很全，插件也挺多的（Knip is Dutch for a "cut". ）
>
> 试了下公司的项目，效果却并不是很好（可能是使用姿势不对）

[useEffect 在 SSR 的时候为什么不执行](https://codewithhugo.com/react-useeffect-ssr/)

> useEffect 只会在 mount/update 之后才会执行（页面上渲染**后**）
>
> Your understanding is correct. useEffect happens _after_ mount/update, but the server doesn’t mount so it doesn’t happen.
>
> — Kent C. Dodds (@kentcdodds) [February 26, 2021](https://twitter.com/kentcdodds/status/1365359744991469570?ref_src=twsrc^tfw)
>
> “it [useEffect] won’t run on the server, but **it also won’t warn**.”
>
> — Hugo (@hugo) February 26, 2021

[TS 10x faster for IntelliSense](https://github.com/johnsoncodehk/typescript-10x-faster-poc)

> volar 作者对于编辑器 TS 推断重计算太慢做的优化的 POC(proof of concept)，优化方法是假定 AST Node 的所有属性一致，就复用之前缓存的计算结果，用来精细化更新。最后也说这个方法不一定能在所有场景使用，针对于特定的性能瓶颈。

[World ID](https://worldcoin.org/blog/announcements/introducing-world-id-and-sdk)

> _As we venture into the exciting new Age of Artificial Intelligence, solving proof of personhood is more important than ever—specifically to ensure democratic access and governance of these systems, fairly distribute the benefits generated and know who and what to trust online._
>
> AI 时代，需要一个真正的身份（Proof of personhood），这个公司用红膜信息生成唯一的 key。[github](https://github.com/worldcoin)

[【好文】从 rust 看编程语言](https://mp.weixin.qq.com/s/ZA-_BARVAWe0Q4eM0lYgwg)

> 讲述了 rust 等不同语言的世界观，编程语言在设计上的取舍；以及 rust 语言的特性，好文，值得反复看，学 rust 之后再看看
>
> Rust 对我们做系统的启示：首先是把系统的运行规则清晰地定义出来，然后对其做类似从特殊化的定理到一般化的公理那样的推敲和抽象，找到满足系统运行的最小化的核心规则，最后用这些规则来限制系统的行为。

[ESM 与 CJS 的 interop（互通）](https://zhuanlan.zhihu.com/p/446113714)

> 来自杨健的文章
>
> 讲述了 ESM 模块和 CJS 模块之间是如何互通的，只需要支持个`import foo from 'bar'`这个 syntax sugar 即可满足（即`import foo from 'bar'` 等价于 `const foo = require('bar')`），然而却同时错误的支持了`export default 'xxx'`这个语法，为后续的交互性问题埋下了祸根
>
> Babel 将 ES 模块转成 CJS 模块，会设置 `__esModule` 属性标记是 ESM 模块，按照 `default` 导出时，能够知道使用 `module.exports.default`（可以跑下 babel 看看）
>
> 当 Node.js 最终发布他们的 ES 模块实现时，他们采用了原来的实现，即`default`导出总是等于`module.exports`，这打破了与现有的 ES 模块生态系统的兼容性(即和 Babel runtime 的兼容性)，这些模块已经被 Babel 交叉编译成 CommonJS 模块。为此，esbuild 做了兼容性修复...
>
> 其他一些：
>
> esbuild 0.14.4 引入的 break change
>
> esbuild 的 changelog 业界良心，能学到新东西
>
> babel 这种大工具也是会犯错（方向错了）
>
> js 真难写哈哈
>
> 杨健写了好多文章...很多都很有兴趣去看

[turbowatch](https://github.com/gajus/turbowatch)

> Extremely fast file change detector and task orchestrator for Node.js.
>
> [nodemon](https://github.com/remy/nodemon/) 的更好替代品，有更丰富的功能比如 nodejs API, retries, debounce, ...

[不推荐 export default](https://zhuanlan.zhihu.com/p/97335917)

> 杨健的文章，深入理解 ES Module & 编译，CJS & ESM
>
> 也就是 `export default` 代码在构建之后，被 node 环境引入的时候需要改写 `require('xxx').default` 这样丑陋的代码等一些问题。
>
> React 不支持 esm 入口，`module.exports = React.default || React` 以及错误用了 `default export`
>
> 推荐：
>
> - 不使用 `export default`
> - 编译器使用 rollup 的 auto 模式

[TS 体操：属性互斥](https://zhuanlan.zhihu.com/p/522191794)

> 常见场景：其中有 a 和 b 字段是二选一的, foo 是可选的。自己也遇到过，挺棘手的。
>
> 文中给出了解决方案
>
> - 手工用 never 处理类型（也是自己用的方法，比较初级，也是核心逻辑）
>
> - 函数重载
>
> - 用体操自动加 never 字段
>
>   - 可以实现 `JustOne<UserConfig, ['a', 'b','c']>`
>
> - XOR（也见过这个体操）
>
>   - 什么是 [XOR](https://en.wikipedia.org/wiki/Exclusive_or)，门电路中，两个输入**互不相同**，但**只要其中一个**有 1 则输出 1，其他输出 0
>
>   - 在 TS 中的场景，比如 `XOR<{ a: boolean}, { b: boolean }>` 就是只能有 `a` 或者 `b` 其中一个给了值（有 1），没有给的情况就是输入 0，如果两个都输入了 1（都有值），就不符合类型
>
>   - ```typescript
>     export type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never }; // => U without T, 把 T 独有的 key 都变成 never
>     export type XOR<T, U> = T | U extends object
>       ? (Without<T, U> & U) | (Without<U, T> & T)
>       : T | U; // 最终生成的结果还是类似自动加 never
>     ```
>
>   - 在这个[回答](https://stackoverflow.com/questions/44425344/typescript-interface-with-xor-barstring-xor-cannumber)中也看到了这段代码

[聊聊前端的未来 & Vercel](https://live.juejin.cn/4354/vercel)

> 我司 web infra 大咖面对面，[文字版](https://zhuanlan.zhihu.com/p/510366735)
>
> 介绍了现代 web 渲染的选型，CSR SSR ISR ...
>
> 细粒度组件渲染
>
> 很多 FAQ 也很有意思

[web container 浅析](https://zhuanlan.zhihu.com/p/446329929)

> 就是魔法站点 https://stackblitz.com/ 能在浏览器跑项目（node）所需的技术实现分析
>
> 浅了解一下，还是挺有意思的，很牛啊，node 模块用 wasm 来写，其他模块用 js 实现，终端的指令也用 js 来实现来模拟 命令行（工作量很大）
>
> 更多可看[这篇官方介绍（mark）](https://blog.stackblitz.com/posts/introducing-webcontainers/)

[write own reactive signal library](https://www.lksh.dev/blog/writing-your-own-reactive-signal-library/)

> 写一个响应式“signal”库，文中给的代码非常简单
>
> 更好的理解响应式 & signal
>
> 以及 Solidjs 的 signal，推荐了他们的 [playground](https://playground.solidjs.com/) 可以看到是如何编译代码的
>
> ```javascript
> let currentListener = undefined;
>
> function createEffect(callback) {
>   currentListener = callback;
>   callback();
>   currentListener = undefined;
> }
>
> function createSignal(initialValue) {
>   let value = initialValue;
>   // a set of callback functions, from createEffect
>   const subscribers = new Set();
>
>   const read = () => {
>     if (currentListener !== undefined) {
>       // before returning, track the current listener
>       subscribers.add(currentListener);
>     }
>     return value;
>   };
>   const write = (newValue) => {
>     value = newValue;
>     // after setting the value, run any subscriber, aka effect, functions
>     subscribers.forEach((fn) => fn());
>   };
>
>   return [read, write];
> }
>
> // use your signal
> const [count, setCount] = createSignal(0);
>
> const button = document.createElement("button");
> createEffect(() => {
>   button.innerText = count();
> });
> button.addEventListener("click", () => {
>   setCount(count() + 1);
> });
>
> document.body.append(button);
> ```

[Visualise your app logic](https://stately.ai/)

> 从 Xstate 文档跳过去的新站点，xstate 团队推出的 studio 用来通过状态机描述 app 的逻辑

[React 还是不好处理 Prop-drilling](https://www.builder.io/blog/react-compiler-will-not-solve-prop-drilling)

> 即使有 React-Forget（自动在编译环节给 FC 中增加 useMemo 和 useCallback），也没办法很好的处理 React prop drilling 的问题（state 变更，组件自上而下的 render）
>
> 而 signal 的方式能够让对应的 subscriber 更新，更加细粒度和高效
>
> builder.io 认为 Signal 更好

[artus-cli](https://github.com/artus-cli/artus-cli)

> 企业级 CLI 框架，个人目前用不到，可以作为 CLI 设计的参考学习

[What is TSDoc](https://tsdoc.org/)

> 微软
>
> 说白话就是在写函数头上的一堆 `/** @params */` 这样的注释，用于更好的生成代码文档
>
> [TSDoc](https://github.com/microsoft/tsdoc) 也是一个开源的库，用来解析 TS DOC 的，当然也有很多其他的工具解析了 DOC
>
> 三个必备条件：
>
> 1. **Extensibility:** Tools must be able to define their own custom tags to represent domain-specific metadata in a natural way.
> 2. **Interoperability（互通性）:** Custom tags **must not prevent other tools from correctly analyzing the comment**. In order words, custom tags must use established syntax patterns that can be safely recognized and discarded during parsing.
> 3. **Familiar syntax:** As much as possible, TSDoc should preserve the familiar style of JSDoc/Markdown. This also maximizes the likelihood that legacy comments will parse correctly as TSDoc.
>
> 为什么 JSDoc 不能成为标准？JSDoc 的语法不是严格要求的，而可以说是通过具体 API 的实现来推到出的注释，不满足 TS 强类型语言的诉求
>
> 有 [Playground](https://tsdoc.org/play)
>
> 差不多了解到这，后续需要深入再说

[v8 更快的访问 super 属性](https://v8.dev/blog/fast-super)

> super 关键字可以访问 class 的父类上的属性，依旧是用了 IC(inline cache)（还得去详细学习下）
>
> class 继承的最根本基础还是原型链！
>
> ```javascript
> class A {}
> A.prototype.x = 100;
>
> class B extends A {
>   m() {
>     return super.x;
>   }
> }
> const b = new B();
> b.m();
> ```
>
> 这里的 B 继承 A，所以 `B.prototype.__proto__` 指向 `A.prototype`，b 是 B 的实例所以 `b.__proto__` 指向 `B.prototype`，执行 `m()` 寻找 `super.x` 的过程就是
>
> 1. 从 _home object_（这里就是 m 所定义的对象 `B.prototype`），目标就是让访问 `super.x` 的过程变得更快！
> 2. 这个 case 中，x 是很快就能被访问到的，但是很多情况可能需要 look up 通过很长的 prototype chain 才能寻找到，此时就需要用 IC 进行加速
> 3. 另说一下，这里即使 `B.prototype` 有 `x` 也不会去找的，因为 `super` 是从 home object 的 `__proto__`（也就是 `B.prototype.__proto__`）去找，receiver 就是访问 super 函数的调用者（receiver）
> 4. 实现细节：
>    1. [Ignition](https://v8.dev/docs/ignition) bytecode, `LdaNamedPropertyFromSuper`, a new IC, `LoadSuperIC`, for speeding up super property loads.
>    2. `LoadSuperIC` reuses the existing IC machinery for property loads, just **with a different lookup start object**.
>    3. 具体代码在 [`JSNativeContextSpecialization::ReduceNamedAccess`](https://source.chromium.org/chromium/chromium/src/+/master:v8/src/compiler/js-native-context-specialization.cc;l=1130)，chromium 项目的在线编辑器，搜索代码比较方便（虽然看不懂代码）
> 5. 最后有一些场景可能是 vm 优化不到的，比如直接给 `super.x = ...` 修改了。或者用 mixin 方式会把 inline cache 变成全局的 cache (megamorphic)就慢了点

[React 2023/3 进展](https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023)

> RSC React Server Component（了解不多）
>
> - async/await 方式来从服务端获取数据
> - 推荐用更高级抽象的框架去使用这个特性（比如 nextjs）
>
> Asset Loading
>
> - Suspense 能够在一些组件/资源/数据加载的时候展示 loading 状态的内容
>
> Document Metadata
>
> React Optimizing Compiler
>
> - React Forget 编译器已经在开发中 and 重构过，能够帮助 react 团队更好的了解 React 的响应式——an automatic _reactivity_ compiler
> - React 的问题是太响应式了（会 re-render 很多次比如深浅比较的问题），React Forget 的意义在于 apps re-render only when state values _meaningfully_ change
> - 完全与 Babel 解耦，核心的编译 API 输入和输出都是 AST，上层可以和 Babel 等多种
> - 更好的理解组件的语义 in JS 语言，需要不断扩展对于 JS 表达式的理解
> - 在 Meta 内部在试点，等验证之后会公布更多细节和开源
>
> Offscreen Rendering
>
> - 很有用的特性，也是推荐通过上层框架封装后再使用，以后就可以用到 vue 中的 keep-alive 了哈哈

[why react re-render](https://www.joshwcomeau.com/react/why-react-re-renders/)

> 一篇很好的 react 入门/深入文章，有可交互的例子说明了 react 的 render loop，和一些我们认为 react 会 render 的误区：
>
> 误区 并不是所有的 props 变化才会引起组件渲染：
>
> - 场景：一个组件 A 的 render 中包含一个没有 props 的纯组件 B，当 A re-render 的时候，B 也会 re-render，理想情况我们直觉是认为无需改动的组件可以跳过渲染，但是作为框架，_it would be counter-productive to memoize every single component we create._ 比较每一次组件是否渲染是很费劲的，所以 react 并没有做，而是推荐用 memo 将组件包裹（之后就看 React Forget 了）
> - context 场景，即使 memo 的组件其中用了 useContext，这个 context 也会被认作是一个 invisible state，可以理解成一个 prop，组件会随着 context 的变化而 rerender
>
> 文章介绍了用 react devtools，控制台的 Profiler 可以看到每次 render 的组件、render 一次所用的时间
>
> 以及一些性能优化的 tips

[shadcn/ui](https://github.com/shadcn/ui)

> 2023 年初开始就很火的一个 ui 库？框架？star 数一路飙升（目前 2023.03.30 13:03:57 +0800 已经 10.1k）
>
> 作者也是 vercel 的，可以直接通过模版 create next app [构建新项目](https://ui.shadcn.com/docs/installation)
>
> - 如果是已有项目，需要手动加一些配置才能更好配合 ui 库
>
> 理念：
>
> - This is **NOT** a component library.
> - It's a collection of re-usable components built using [Radix UI](https://radix-ui.com/) and [Tailwind CSS](https://tailwindcss.com/).
> - 不发布 npm 包，而是自己 **copy** 代码到项目，自定义样式
>
> [组件](https://ui.shadcn.com/docs/primitives/accordion)也挺好看的，组件的[源码](https://github.com/shadcn/ui/tree/main/apps/www/components/ui)都在文档中～

[Radix UI](https://www.radix-ui.com/)

> 那就再来看一下 Radix UI 是什么
>
> [目标 & Vision](https://www.radix-ui.com/docs/primitives/overview/introduction)
>
> - a low-level UI component library with a focus on accessibility, customization and developer experience.
> - Radix UI 实际上是为当下我们普遍已经[熟悉](https://www.w3.org/WAI/ARIA/apg/#aria_ex)的 UI 组件（checkbox、slider、toast ...）做了一层更好的抽象，但目前的 Web 平台并没有这些交互组件很好的实现（不一致性问题肯定也存在），所以码农们会自己去实现各种组件（项目里写的、好一些的开源的库）但并没那么“完美”（无障碍、功能、样式），所以 Radix 的目标就是构建一套更完备的组件库
>
> 特性：
>
> - Accessible，无障碍很完善
> - Unstyled，无预设样式，可以完全自定义
> - Opened，灵活开放
> - Uncontrolled
> - DX

[tsup](https://github.com/egoist/tsup)

> 好家伙，又是 [egoist](https://github.com/egoist) 的库，真神人
>
> 底层是 esbuild，能够打包 js, ts, tsx

[浅学分布式系统的服务发现](https://juejin.cn/post/6844903937653342216)

> 为什么需要服务发现？
>
> - 通常我们访问服务是需要知道服务实例的 IP 地址和端口，固定的我们便可以直接写在配置文件中，但大多数线上环境尤其是容器部署的情况下，实例地址都是动态分配的，只有实际部署之后才能得到地址，只能通过服务发现组件解析服务名来获取地址和端口
>   - 这里的服务名应该就是自己定义的（比如我司的 `p.s.m`）
>
> 一个标准的服务发现架构主要有三部分组成分别是服务注册中心、服务调用者、服务提供者
>
> 三者关系也就是：
>
> ```mermaid
> flowchart TB
>     服务提供者 --> |注册| 服务注册中心
>     服务调用者 --> 服务提供者
>     服务调用者 --> |服务订阅| 服务注册中心
>     服务提供者 -.-> |变更通知| 服务调用者
> ```
>
> 服务注册中心是核心组件：
>
> - 容错（Fault Tolerance）：服务注册中心保存了分布式系统中所有服务名与服务实例地址映射，一旦故障必将导致整个系统不可用，是整个分布式系统核心，必须具备高可用性；
> - 服务健康检查（Service Health Check）：服务注册中心必须要能及时发现故障实例并将其注销以防止被错误访问；
> - 监视器（Watcher）：服务注册中心必须具备及时通知服务调用者服务实例注册或注销的能力，以便服务调用者及时采取措施。
>
> 其实和域名很相似
>
> 文中介绍了现有的一些方案：DNS，mDNS，Zookeeper，Etcd，Consul

[aPaaS 入门](https://zhuanlan.zhihu.com/p/69168598)

> 互联网行业就喜欢搞一些单词的缩写，SaaS、PaaS、IaaS。都属于云计算
>
> 能够打包这些技术/装备，开发者（用户）都无需自建和维护了，公司提供
>
> 1. 应用（application）
> 2. 数据（data）
> 3. 运行库（runtime）
> 4. 中间件（middleware）
> 5. 操作系统（OS）
> 6. 虚拟化技术（virtualization）
> 7. 服务器（servers）
> 8. 存储（storage）
> 9. 网络（networking）
>
> aPaaS 可以理解为 PaaS 的一种子形式。application Platform as a Service，和 PaaS 的区别是非技术人员可以直接在云端完成应用的搭建、部署、使用、更新和管理
>
> 厂商有 Redmine，Jira，Odoo，Smartsheet, Airtable 和 Zoho Creator（文章是 2019 年的）
>
> 国外的 [retool](https://retool.com/) 也非常牛
>
> 好处：
>
> - 零代码/低代码
> - 可扩展性
> - 云服务
>
> 当然也有局限性，不适合一些企业

[How Warp Works](https://www.warp.dev/blog/how-warp-works)

> Warp 的实现（纯 Rust + Metal，performance first）
>
> Terminal → Shell
>
> 文章讲的还算是挺细节的
>
> - Warp 的一些特性/目标（现代性）：速度/性能；和现有的 shell 兼容（zsh、Bash、Fish）；多平台（还需要支持 web）；支持 blocks；任意的 UI 元素了；native and intuitive editing
> - 选择了 Rust + Metal for 性能，直接选择 Metal GPU 渲染是因为快 and 只想做 Mac 系统；选择 Rust 因为他快并且[社区](https://crates.io/)还不错，对跨平台的支持也很好（也能编译到 WASM）。
> - 为什么直接渲染到 GPU 呢：主要还是快，写 shader 代码封装了少量的基础元素（rectangle、image、glyphs），和 [Nathan Sobo](https://github.com/nathansobo)（Atom、zed）的作者一起开发了一个 **Rust 的 UI 框架**（之后也许会开源出来，很期待）
> - Blocks 的实现，为什么看不到其他 terminal 有 block 这个 feature，因为终端其实不知道到底是什么程序在跑，不知道在 shell 内部发生了什么。Warp 是通过 custom DCS(Device Control String) 包含了 metadata 来渲染一个 session 的内容（具体没怎么看）（顺带提到了 [upterm](https://github.com/railsware/upterm)）
> - Input Editor，也是和 atom 的作者一起，相当于重新实现了一个编辑输入栏，包含了很多使用的快捷键（通过一个事件分发系统实现）,We intentionally designed our editor to be an Operation-based [CRDT](https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type) from the start。为了之后可以实时合作。（BTW CRDT 真的出现太多次了，只要是实时编辑就有，该去看看了）
>
> 未来的一些方向就不提了，因为这个 bog 已经是比较久的了（21 年的）
>
> Performance is one of our most important features
>
> Warp 社区好多 issues，甚至 [powerlevel10k 的作者都希望他直接集成](https://github.com/warpdotdev/Warp/issues/2851)
>
> BTW 从 upterm 看到了 [hyper](https://github.com/vercel/hyper)。。vercel 公司的 web 技术 terminal（基于 electron）

2023.4

[Linter?](https://twitter.com/dan_abramov/status/1086215004808978434)

> 来自 Dan 的 Twitter 吐槽
>
> 同样也有 Dan 的这篇[文章](https://overreacted.io/goodbye-clean-code/)，做些摘录：
>
> Obsessing with “clean code” and removing duplication is a phase many of us go through.
>
> Coding is a journey. Think how far you came from your first line of code to where you are now.
>
> **Don’t be a clean code zealot.**
>
> It’s a defense mechanism when you’re not yet sure how a change would affect the codebase but you need guidance in a sea of unknowns.
>
> Let clean code guide you. **Then let it go.**

[Optimize for Change](https://overreacted.io/optimized-for-change/)

> Dan 的文章
>
> _Good_ API design is memorable and unambiguous. It encourages readable, correct and performant code, and helps developers fall into [the pit of success](https://blog.codinghorror.com/falling-into-the-pit-of-success/).
>
> A slight change in requirements can make the most elegant code fall apart.
>
> _Great_ APIs not only let you fall into a pit of success, but help you _stay_ there.

[JSON URL](https://twitter.com/housecor/status/1555555629351198721?s=12&t=dXathnvNfnF_vdpC1hrLdQ)

> 推荐的 [JSONCrush](https://github.com/KilledByAPixel/JSONCrush) 这个库，能很高效的压缩 JSON String，让通常放在 URL 上的 JSON 数据变小（头疼问题）

[2023 年学传统软件开发还有意义吗](https://anduin.aiursoft.cn/post/2023/3/31/classic)

> Anduin Xue 大佬的博文
>
> _只是不要把重心放在传统软件工程上了，就像我的学习重心也不是汇编。但是绝对不是不学，而是对整个宏观知识都要有更高的要求的同时，将侧重点放在 AI 的研究方向上。_
>
> _例如，把 70%的精力放在 AI 相关领域，20%的精力放在传统软件工程（面向对象程序设计，MVVM，依赖注入，数据结构，算法，前后端分离，组件化开发，依赖管理，包管理，操作系统，虚拟化，云计算，分布式系统，数据库等），10%的精力放在考古技术上（C、汇编、计算机组成原理，数字电路）。_
>
> [计算机底层知识到底值得学么](https://www.zhihu.com/question/264426279/answer/1840524133) 的这个回答，提到的 [Hyrum's Law](https://www.hyrumslaw.com/)：
>
> 大意是指，如果一个接口存在足够多的用户，不论你在接口层面做出何种“契约”，整个系统每一个可观测行为都可能会被某个用户所依赖。
>
> 某种意义上计算机中的许多顶层抽象是“不完全成功”的，虽然它确实能够降低编程的门槛，但事实上作为专业程序员所需要掌握的底层知识并没有因此减少多少。

[Chrome112 支持 CSS 嵌套 document.domain 禁用](https://zhuanlan.zhihu.com/p/620412706)

> CSS 嵌套不多说了，就是 less 等后处理器的特性，但是为了兼容老版本，还是不要纯 CSS 了吧
>
> document.domain 正式禁用，为了更加安全
>
> - 之前可以在 iframe 跨域通信的场景，将主 frame 和 iframe 的 `document.domain` 都设置成相同的域名，但是不够安全，跨域通信方案还是选用 `postMessage` 或其他

### 【资讯 & 潮流】

> **需要标注收录时间**

[字节海外版小红书 lemon8 在美国火了](https://36kr.com/p/2209297991414400)

> 2023.04.12 13:20:39 +0800

2023.3.28 坂本龙一教授去世

> Sad. R.I.P

[electron 的十年](https://www.electronjs.org/blog/10-years-of-electron)

> 2023.03.23 12:49:02 +0800
>
> Electron 从 2013.3.13 到现在已经十年了，是最稳定和主流的桌面应用构建工具之一。
>
> blog 介绍了起源，一开始叫 Atom Shell，结合了 nodejs 和 chromium 让其成为强有力的 web 技术的桌面构建工具。很多应用都是用 electron 开发的（Slack、Figma、VScode、Notion）
>
> Electron 的 release 节奏跟随 chromium 的发布节奏
>
> 通过建立 Working Group 来组织
>
> 自动化：_Not Goma_ 定制的 C++ 编译工具（基于 google 的 Goma）；Sheriff 开源的权限管理工具；Github Bots

[改个应用名来提升性能](https://mp.weixin.qq.com/s/12bP8kEZ-FOArr3ypdtluw)

> 2023.03.23 10:44:37 +0800
>
> Yandex 浏览器也是基于 chromium 内核的，但是他们发现即使自己的功能和 chrome 的一模一样，但是还是出现了性能问题，于是尝试把 browser.exe 改成了 chrome.exe 居然就好了。。。
>
> 他们发现 AMD 显卡会硬编码优化进程/程序名称列表，NVIDIA 显卡还不清楚，反正他们让 AMB 显卡也加入 Yandex 了

[Microsoft 365 Copilot 发布了](https://mp.weixin.qq.com/s/YgiurOE0uZ7lRDx1ehpbhQ)

> 2023.03.17 13:43:38 +0800
>
> GPT-4 全面接入微软 office 全家桶，要失业了

[永不丢失的网络身份](https://github.com/ruanyf/weekly/blob/master/docs/issue-246.md)

> 2023.03.17 13:01:27 +0800
>
> 来自 ruanyifeng 的 weekly
>
> 社交网络账号、邮箱，都是所属于公司，而非属于我们自己，**有没有办法，让网络身份真正属于使用者，完全受你控制，其他任何人都无法夺走，永不丢失呢？**
>
> 回答是有办法的，而且已经实现了。
>
> 方法就是你用一个密钥对，作为自己的网络身份，公钥是你的用户 ID，私钥用来身份验证。
>
> 这保证了每个用户的身份都是唯一的，只要私钥不泄漏，任何人都无法夺走你的账号。
>
> 事实上，加密货币的身份体系就是这样设计的。用户用钱包表示身份，每个钱包的编号就是用户的公钥，必须用对应的私钥，才能往里面存取加密货币。这保证了你对钱包的绝对控制。
>
> OpenAI 公司的首席执行官 [WorldCoin 项目](https://worldcoin.org/)：通过虹膜信息存进区区块链生成密钥对作为网络 ID

[core-js 作者开源历程](https://github.com/zloirock/core-js/blob/master/docs/2023-02-14-so-whats-next.md)

> 2023.03
>
> _It is not a framework or a library, whose usage requires the developer to know their API, periodically look at the documentation, or at least remember that he or she is using it._
>
> _...in November 2014, I published `core-js` as an open-source project. Maybe it was the biggest mistake in my life._
>
> I didn't promote myself or the project. \*This is the second mistake. `core-js` didn't have a website or social media accounts, only GitHub. I did not show up at conferences to talk about it. I wrote almost no posts about it. I was just making a really useful and wanted part of the modern development stack, and I was happy about that. I gave developers a chance to use the most modern and really necessary JavaScript features without waiting for years until they are implemented in all required engines, without thinking about compatibility and bugs — and they started to use it.

[BitTorrent 20 年的故事](https://torrentfreak.com/bittorrent-turns-20-the-file-sharing-revolution-revisited-210702/)

> 2023.02.18 12:14:30
>
> Bit torrent 相信大家都是常用了，诞生于 2001 年，发明者叫 Bram Cohen
>
> 用户帮助的分布式内容网络协议；结合 Web、搜索引擎；也遇到了流量问题，占据了 1/3 的网络流量。BitTorrent Inc. 公司成立...
>
> 随着流量费用的降低，BitTorrent 还是非常有技术优势并且仍是一个高级、新技术，始终能在互联网历史中站稳脚跟

### 【Art & Design】

[7 photography trends in 2021](https://blog.adobe.com/en/publish/2021/01/04/7-photography-trends-to-watch-in-2021.html#gs.0ij8bg)

> 7 大摄影风格趋势
>
> 1. Inclusivity 包容性，消费者喜欢看到自己（个性、习惯等）能够被 reflect 在照片中
> 2. Fantasy meets reality with digital art 一种虚无主义？（escapism）_Being a form of escapism, this trend will be less about subtly building upon reality and more about completely reimagining what’s captured on camera into otherworldly scenes that enliven the imagination._
> 3. Nostalgia _For 2021, that nostalgia will remain another form of escapism. Escaping via futurism is less likely, given we are looking to get away from uncertainty and latch back onto something that feels solid and known — the past._
> 4. Smarter edits using AI and machine learning
> 5. Artistic photo-documentary 对于 event 的记录可以不是如此写实和原始的，而是可以加上艺术的元素或趋势（比如 nostalgia）
> 6. Creative drone photography drone 无人机摄影
> 7. Authenticity _While the fantasies of digital art can give us the escape we crave from pandemic life, it is realism we crave when it comes to imagery of people and our everyday world._ 8.

[Fractal Garden](https://www.fractal.garden/)

> 递归的美、数学的美，也有 github 指路，挺有意思

https://garryui.cn/

> 一个很炫酷的网站，PC 支持，卡通风，动效很强

[画图工具](https://www.bmpi.dev/self/my-drawing-toolbox/)

> 画图工具汇总！
>
> highlight：
>
> - ASCII 风格：https://asciiflow.com/#/
>
> ```
>                    xxxx
>                   x    x
>        xx         x    x
>      xxx xxx      x    x
>      x     xx     x    x
>      x     xx     x    x
>      x     x      x    x
>       x   xx      x   x
>       xxx x       xx xx
>    xxxxxxx          xx
>   xx xxxxxxxxxxxxxxxxxx
>  x                     xxxx
>  x    xxxx         xxx     xx
> x    xx  xx        x  xxx   xx
> x    xxxxxx        xxxxxx     x
> x                             x
>  xx        xxxx   xx          x
>   xxx         xxxxx          xx
>       x  x                 xx
>            x  x x xxxxxxx x
> ```
>
> 思考摘录：没有一种工具是万能的，万能如 Excalidraw 也无法替代 Lucidchart/Draw.io/Google Drawings/Visio 这些复杂的工具（他们更适合复杂的对精确性有高度要求的图）

## Next

[Performance · microsoft/TypeScript Wiki](Reading%20List%2068c05d9b17b04eac936dcb715058a8ab/Performance%20%C2%B7%20microsoft%20TypeScript%20Wiki%208f194d0890d84c6dad4ba6627a3c4cc1.md)

[TypeScript: Documentation - JSX](Reading%20List%2068c05d9b17b04eac936dcb715058a8ab/TypeScript%20Documentation%20-%20JSX%20a8ba238ad40c449694cb6a2380bffdbd.md)

[Typescript: What’s the Difference between Omit and Exclude? | by Nathan Le Master | Medium](Reading%20List%2068c05d9b17b04eac936dcb715058a8ab/Typescript%20What%E2%80%99s%20the%20Difference%20between%20Omit%20and%20%20e363d00b3edc441ca2ed5cb02fbb878a.md)

[CSS 排版与正常流 —— 重学 CSS - 知乎](Reading%20List%2068c05d9b17b04eac936dcb715058a8ab/CSS%20%E6%8E%92%E7%89%88%E4%B8%8E%E6%AD%A3%E5%B8%B8%E6%B5%81%20%E2%80%94%E2%80%94%20%E9%87%8D%E5%AD%A6CSS%20-%20%E7%9F%A5%E4%B9%8E%20e66e872f58ee4ae68e1c88c8f501e2ec.md)

[google/brotli: Brotli compression format](Reading%20List%2068c05d9b17b04eac936dcb715058a8ab/google%20brotli%20Brotli%20compression%20format%20b8954b5e2c7a45deb2cbd5cba5928f7e.md)

[新技术学习不完全指北：以 Rust 为例](Reading%20List%2068c05d9b17b04eac936dcb715058a8ab/%E6%96%B0%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8C%97%EF%BC%9A%E4%BB%A5%20Rust%20%E4%B8%BA%E4%BE%8B%205a04875dff844f358c7e4cab99680e28.md)

[Use React.memo() wisely](<Reading%20List%2068c05d9b17b04eac936dcb715058a8ab/Use%20React%20memo()%20wisely%2000903348fad6471abc54ef23ed5a6bfd.md>)

[9 Ways To Implement CSS in React JS | by Dmitry Nozhenko | Medium](Reading%20List%2068c05d9b17b04eac936dcb715058a8ab/9%20Ways%20To%20Implement%20CSS%20in%20React%20JS%20by%20Dmitry%20Nozh%2046b33adf80724da6a2555302acaee27f.md)

[Quick Start | Redux Toolkit](Reading%20List%2068c05d9b17b04eac936dcb715058a8ab/Quick%20Start%20Redux%20Toolkit%2009ebca7c69a94600be5590ecb7ac48ba.md)

[关于 monorepo 的一些尝试 - 知乎](Reading%20List%2068c05d9b17b04eac936dcb715058a8ab/%E5%85%B3%E4%BA%8E%20monorepo%20%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%9D%E8%AF%95%20-%20%E7%9F%A5%E4%B9%8E%20c3307682d9644cb280c8e36dea1cb988.md)

[nginx 入门](https://juejin.cn/post/6844904144235413512)
