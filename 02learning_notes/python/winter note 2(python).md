# Python 学习

    python的自学从几个月前断断续续地进行，想好好利用这个寒假，好好地学一学。

## 回顾

    已学习：基本操作、函数
    已有C++的一定基础，只要注意python中比较特殊的部分就行

---

## 进入正题

### lambda 表达式

#### 1. 语法

    lambda _args: _expression

    lambda函数是匿名的：所谓匿名函数，通俗地说就是没有名字的函数。lambda函数没有名字。

    lambda函数有输入和输出：输入是传入到参数列表_args的值，输出是根据表达式_expression计算得到的值。

    lambda函数一般功能简单：单行_expression决定了lambda函数不可能完成复杂的逻辑，只能完成非常简单的功能。由于其实现的功能一目了然，甚至不需要专门的名字来说明。

#### 2. 一些小例子

    lambda x: x ** 2
    lambda x, y: x * y
    lambda *args: sum(args)
    lambda **kwargs: 1

- 在变量名前加\*表示可以传入任意数量个参数
- 在变量名前有\*\*表示用“关键字=值”的方式传递一个字典给函数

  - ```
    def func(**args):
      	d = {}
      	for key, value in args.items():
          	d[key] = value
    	print(d)

    func(year='2019', month='1')
    ```

  ```
  - {'year': '2019', 'month': '1'}
  ```

#### 3. 使用方法

    1. 直接将lambda函数赋值给一个变量，让这个变量具有函数的功能，类似于C++中的仿函数(functor)
    e.g. square = lambda x: x * x

    2. 按照字典的值(value)进行排序，得到key的有序序列
    e.g sorted(a_dict, key=lambda x:x[1])

从 CSDN 上看到的

> 例如，为了把标准库 time 中的函数 sleep 的功能屏蔽(Mock)，我们可以在程序初始化时调用：time.sleep=lambda x:None。这样，在后续代码中调用**time**库的 sleep 函数将不会执行原有的功能。例如，执行 time.sleep(3)时，程序不会休眠 3 秒钟，而是什么都不做.

> 函数的返回值也可以是函数。例如 return lambda x, y: x+y 返回一个加法函数。这时，lambda 函数实际上是定义在某个函数内部的函数，称之为嵌套函数，或者内部函数。对应的，将包含嵌套函数的函数称之为外部函数。内部函数能够访问外部函数的局部变量，这个特性是闭包(Closure)编程的基础，在这里我们不展开。

---

将 lambda 函数作为参数传递给其他函数。

> **filter**函数。此时 lambda 函数用于指定过滤列表元素的条件。例如 filter(lambda x: x % 3 == 0, [1, 2, 3])指定将列表[1,2,3]中能够被 3 整除的元素过滤出来，其结果是[3]。

> **sorted**函数。此时 lambda 函数用于指定对列表中所有元素进行排序的准则。例如 sorted([1, 2, 3, 4, 5, 6, 7, 8, 9], key=lambda x: abs(5-x))将列表[1, 2, 3, 4, 5, 6, 7, 8, 9]按照元素与 5 距离从小到大进行排序，其结果是[5, 4, 6, 3, 7, 2, 8, 1, 9]。

> **map**函数。此时 lambda 函数用于指定对列表中每一个元素的共同操作。例如 map(lambda x: x+1, [1, 2,3])将列表[1, 2, 3]中的元素分别加 1，其结果[2, 3, 4]。

> **reduce**函数。此时 lambda 函数用于指定列表中两两相邻元素的结合条件。例如 reduce(lambda a, b: '{}, {}'.format(a, b), [1, 2, 3, 4, 5, 6, 7, 8, 9])将列表  [1, 2, 3, 4, 5, 6, 7, 8, 9]中的元素从左往右两两以逗号分隔的字符的形式依次结合起来，其结果是'1, 2, 3, 4, 5, 6, 7, 8, 9'。

### 一些小东西

- 列表的分片: s[:], s[:-1], s[n:m]。分片区间[n, m)，当 n 或 m 为负值的时候，实际值为 len(s)+n。
- 列表的 pop(): 不要和 stack 的 pop 搞起来了，列表 pop 是删除最后一个元素！
- 列表的 remove(value): 可以直接将列表中的 value 这个值删掉
- .sort()与 sorted(sth): s.sort()是永久排序，sorted 排序一个对象，返回的有序的一个列表，不会对原始对象做改变
- .reverse(): 永久逆序列表
- 生成列表的小技巧： squares = [x ** 2 for x in range(11)]，此时 squares 的内容是 0~10 的平方数（且有序）。这个很实用
- 复制列表：**copy** 和 **deepcopy**，涉及到 python 中变量存储的方式，下文会谈，这边先提到一下。（自己思考思考）
- 字典删除键-值对： 用**del**关键字。del d['key']
- 字典添加键-值对： 直接 d['new_key'] = new_value 即可
- 遍历字典： for key, value in d.items():

### 函数

    只记录一些比较新的点

1. 函数的参数传递：
   1. 有默认值的情况和 C++一样（顺序，默认值的位置）
   2. 可以用关键字传递形参，e.g. fun(name='abc')，此时不关乎顺序
   3. 形参表接受任意个参数，在形参名前加\*
      e.g.

```
			def square_sum(*args):
				res = sum([x ** 2 for x in args])
				return res
```

    这里的args其实是一个元组(tuple)

    4. 	使用任意数量的关键字实参，上面提到过
    	e.g.

```
			def add_info(user_info, **new_info):
				for key, value in new_info.items():
					user_info[key] = value
```

    这里的new_info接受到的只一个字典

2. 函数的命名法则
   这个看个人喜好吧，只要表达清楚，看得懂就行，我采用下划线命名法

### 类

    终于到了面向对象的东西了，看看和C++的差别有多少呢

1. 编码风格：
   1. python 中的类名称规定是首字母大写的大驼峰法命名
   2. 实例名和模块名用下划线命名法，类之间用两个空行分开
   3. 在 class Name() 的括号中，到底要不要加 object 呢？网上看了一下说 python2 最好加 object，暂时我先不加了，遇到问题再说
2. 成员函数：
   1. 构造函数 **init**(self):
   2. 所有成员函数的形参列表都要加上*self*，类似于 c++类中的*this*指针，只不过 python 用的是显式但不用真正传递，因此，每一个成员数据或者函数在类内使用的时候都要加上**_self._**
3. 关于 public 和 private：
   好像在 python 的类中是没有明确说明有这两种以及 protected 情况的。经过我一番搜索，发现三种属性可以用下划线来解决。
   - 没有下划线的变量，如 self.public 是**public**属性
   - 有一个下划线的，如 self.\_protected 是**protected**属性（只有子类可以访问，且不能通过*import*导入）
   - 有两个下划线的，如 self.\_\_private 是**private**属性
4. 继承：
   1. 语法：在子类的括号中加上父类的名称
   2. 特殊函数**super()**：写在子类的构造函数中
      e.g.

```
			class Child(Father):
				def __init__(self, sth):
				"""初始化父类"""
					super().__init__(sth)
```

    类似C++中在初始化行构造父类
    3. 覆盖父类的函数/方法：只要子类的函数名和父类有的函数重复了就会*override*
    4. python的继承顺序，简要提一下：python2是深度优先，python3是广度优先，具体可以参考：<a href="http://blog.51cto.com/10836356/2108796" target="_blank">Python类的继承</a>

5. 其他：
   暂时没有学到什么东西了，碰到了再深入下去。

### Python 特殊的引用变量

- 其实 python 中每个变量名所拥有的内容其实是一个引用（指针）指向的是一个静态池中的常量
- 所以当变量给变量赋值的时候，给的值并不是他所对应的常量，而是将自己的指针的地址给了另一个变量，导致了这两个变量同时共享这一个常量
- 如果改变一个变量中的值，即改变了这个常量的值，那么另一个变量的值也随之改变。
- 因此在列表赋值的时候，不要直接用**=**，而是用**a = s[:]**的方式，因为 s[:]是 s 的一份拷贝，新的列表，这就是上面所提到的一种 copy，这种方法等效于**a = s.copy()**
  e.g.

```
>>> a = [1, 2, [3, 4]]
>>> b = a.copy()
>>> b[0] = 3
>>> b
	[3, 2, [3, 4]]
>>> a
	[1, 2, [3, 4]]
#a没有受到影响，拷贝成功
```

- 但是，注意 b 这里是二维的，如果改变了第二位的列表中的值，a 会受到影响吗。
  e.g.

```
>>> b[2][0] = 123
>>> b
	[3, 2, [123, 4]]
>>> a
	[1, 2, [123, 4]]
#a受到影响了！
```

- 可以想象到，在 copy 的过程中是将 a 列表中每个元素的值重新拷贝了一份新的引用给 b，但是，中间嵌套的列表**[2, 3, 4]**（看做一个元素）的值其实是一个引用（这里要好好想一下哦），把一个一样的值（也就是地址一样的指针）给了 b，那么其实 b 这个位置的元素和 a 这个位置的元素共享的是一个地址，会受影响。
- 为了解决这个问题，`import copy`，使用*copy.deepcopy()*
  e.g.

```
>>> b = copy.deepcopy(a)
#此时b和a不会相互影响，自己做一下实验吧
```

- 根据我自己的理解解释一下（下次去查一下官方说明），deepcopy 所做的事情其实是**递归 copy**，层层深入 copy
- 还有一件比较重要的事情：根据上述所说，**operator =**赋值的都是引用，因此函数在形实结合之后，函数体内改变形参同样会改变实参，如果不想这样，怎么做上面写了几个方法。有点像 c++中默认传递*T&*（引用）类型。

### python 中的多文件

- 据我现在的理解，就是将函数，类写在别的**.py**文件，用的时候 import 即可。
