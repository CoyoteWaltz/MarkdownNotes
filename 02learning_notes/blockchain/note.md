# Tortoise and Hares Consensus: the Meshcash Framework for Incentive-Compatible, Scalable Cryptocurrencies

Tortoise and Hares Consensus: 一种共识机制（网络中的参与者对某个信息达成一致，比如谁挖到一个 block 了）

the Meshcash Framework: mesh 网 cash 框架？

Incentive-Compatible, Scalable Cryptocurrencies: 有激励制度的（奖励比特币）可扩展（？）的加密货币

## Abstract

一种 cryptocurrency protocols

结合了：

1. a novel, proof-of-work based, permissionless **byzantine consensus protocol** (the tortoise) 拜占庭共识协议？能保证：
   - eventual consensus
   - irreversibility 不可逆性
2. a possibly-faulty but quick consensus protocol (the hare) 有可能犯错？，但是效率很高的共识机制协议

构造方法是模块化的（ modular ）

结合这两者之后的世界级优势（ world properties ）：

- consensus is **quick** if the hare protocol succeeds, but guaranteed even if it is faulty. 后半句翻译：即使存在缺陷（）也会有保障。

tortoise 协议没有 leader-election (e.g., the single miner who managed to extend the longest chain)

采用了**异步拜占庭协议**（ asynchronous byzantine agreement protocols ）的思想来**逐渐收敛一个共识**（ to gradually converge to a consensus ）（这里不太明白）

### Meshcash

设计的理念是 **race-free** ，在生成下一个区块的时候是没有竞争的，正常（不作弊）生成的区块都是有奖励的

This property, which we define formally as a **game-theoretic** notion, turns out to be useful in analyzing rational miners’ behavior: we prove (using a generalization of the blockchain mining games of Kiayias et al.) that race-free blockchain protocols are incentive-compatible and satisfy **linearity of rewards** (i.e., a party receives rewards proportional to its computational power).

一种博弈的特性？可以来分析合理矿工的行为，同时也是激励兼容（有奖励的），满足线性的奖励（比如矿工的奖励和他的计算能力成比例）

同时 Meshcash 可以在一个高频率的区块生产率下运行（？），尽管会有网络传播信息的延迟

it allows us to lower both the **variance** and the **expected time between blocks for honest miners**; together with linearity of rewards, this makes pooled mining far less attractive. Pooled mining: 集合采矿

降低了矿工之间的差异性（提升平等性）以及挖矿所需的时间

**race-free protocols** 的扩展性更好（ **scale more easily** ）？可以容纳更多的交易？

因为 the network propagation delays are not a factor in terms of rewards, **which removes the main impediment to accommodating a larger volume of transactions**. 如果是有竞争的协议，需要网络来同步每个矿工的信息，所以每次挖矿的时间就长了，因为传输数据需要花时间，所以每个区块所包含的交易数量也就相对少了。如果网络延迟不作为挖矿成功的一个因素，那么一个区块所包含的交易数量也可以很多。

具体是怎么做到 race-free 的呢？

### Conclusion

We formally prove that all of our guarantees hold in the **asynchronous communication model** of Pass, Seeman and shelat, and against a constant fraction of byzantine (malicious) miners; not just rational ones.

在异步交流模型中都是有效的，并且能抵御拜占庭恶意矿工

## 1 Introduction

一个有效的货币需要满足以下特质：

- 有限的提供（ Limited Supply ）
- 不能双重花费（ No double spending ）
- 存活性（ Liveness ）？
- 对（交易）历史的共识（ Consensus on history ）
- （交易）不可逆（ Irreversibility ）

这些是每个货币都拥有的，但是传统货币都太依赖一个单独的管理中心来保证这些特质。比特币是一种将这些特性“分布”的一种方法，让更大的社区去保证这些信用特性。

In Bitcoin, the assumption is that **the majority of the active participants behaves honestly**, where majority is _measured by computational power_. 用计算能力去衡量大部分的参与者的诚信。

在中本聪的描述中，为了实现以上的愿望，构造了一个**分布式时间戳服务器（ distributed timestamping server ）**，可以使得所有参与者认同交易历史的有效性，特别的是，可以按照交易出现的顺序。大致上可以认为是参与者对他们认为是有效的交易进行**投票**，大部分人投票的交易就“获胜”了（存疑），理想状态是每个人都有相同的投票数，这里的“人”在互联网中可以是 ip 地址，但是互联网中没有身份这个机制，恶意的一方可以伪造身份，**所以比特币强制使用“一资源一投票（ one-resource- one-vote ）”的规则，其中“资源”就对应着一台计算机的算力。**

这样一来，参与者们可以生产他们的“工作量证明机制（ Proof of Work ）”，每一个证明对应着一次投票。为了减少交流（信息传输的消耗），每一个工作量证明都是一个彩票，只有中彩票的那个人能进行投票。

> To reduce communication, Bitcoin actually uses a lottery system, where each Proof of Work (PoW) corresponds to a lottery ticket, and only the winning ticket gets to vote.

_这里的彩票中奖就是指计算出的 hash 满足了前几位是 0 的条件，即挖矿成功。_

> The decentralized nature of the Bitcoin protocol stems from the fact that it allows anyone who contributes computational power to participate. In this sense, Bitcoin is regarded to be a permissionless consensus protocol.

比特币分布式的本质源自于“让所有能提供算力的人加入”的想法，所以它被认为是一个没有门槛的（ permissionless ）共识机制。

学术界研究比特币在未来遇到的阻碍：

- 算力集中的组织带来的中心化
- 网络扩展性的局限
- 巨大的交易量
- 私自的挖矿

### 1.1 Our Contributions

Meshcash 框架可以解决或者迁移上面提到的风险。

Meshcash 背后最根本的思想是一个新的共识机制，不通过一个竞赛的方式去竞选唯一的赢家，这个共识机制思想也是从“拜占庭协议”得到的。一个矿工挖到矿不会影响另一个矿工挖到矿。（？）

> We use ideas from the byzantine agreement literature to achieve a consensus on all generated blocks.In particular, this means that one miner’s success does not prevent the success of another.

模块化的构造方式，结合（ long-term ）“乌龟”共识机制（能够保证最终达成共识和不可逆性）和“野兔”共识机制（ short-term ）（快速达成共识，但是不一定保证可逆性），两者结合可以达到最好的效果。

已经在异步交流模型中证明了即使有恶意矿空也能保证安全。同时可以保证是有奖励激励的。

在结构上用网状结构有向无环图（ DAG ）取代了之前的单链，这使得多个区块能够并行共存，同时奖励仍与工作量表现相关。这样可以带来一些好的因素（来减轻比特币会面临的风险）：

- **大大降低矿池中的奖励（减少中心化矿池的形成）：**对于业余爱好的矿工来说，挖矿是十分困难的（100000 个矿工在相同的哈希率下，由于比特币 10 分钟出一个矿，那么平均每个人挖到矿等待时间是 1000000 分钟，这对于个人来说很难接受），于是加入集中的矿池，但是矿池的扩容的速度极快，这对于去中心化是不利的。在 Meshcash 中，很多区块可以同时在一个时间单位内产生，这样个体矿工能更容易获得奖励。

- **更好的（区块容量）伸缩性：**之前限制区块容量的因素是在网络中传递信息的延迟，但在 Meshcash 中，网络传播延迟不是一个重要影响，因为挖矿的时候没有“竞争”，所以允许系统挖更大的区块。
- **奖励机制验证：**
- **奖励机制传播：**比特币矿工或许不会将自己收到的交易信息传播给其他节点，这样可以提升自己挖矿成功的概率，但是这样对于整个系统来说是不利的，会降低交易被确认的等待时间和节奏。在 Meshcash 中，交易的奖励费用会被分发在最近层中构造区块的矿工，这样如果有个体矿工保留交易信息也不会获益了。
- **抵御贿赂：**
- **抵御分支：**是协议中非常重要的特性

## 2 共识机制

### 2.1 概览

简单来说，Meshcash 中工作量证明机制和比特币的没有很大的差别，但是在区块链结构上，Meshcash 采用了层级的有向无环图，每一个区块都指向前一层。框架的共识机制结合了两个快慢共识机制，快机制“野兔”，能够完成对最近历史交易的验证（野兔机制决定了验证前几层的数量），慢机制“乌龟”机制来验证久远的交易历史，用所有相继的区块**加权投票**的方式判断一个区块是否是正确历史记录（主链）的一部分。

### 2.2 广义有向无环区块图建模

参考了异步交流模型 Pass, Seeman, shelat 将区块链转变为有向无环区块图，以下用英文简称 blockDAG 。定义了交互式的协议，每个参与者都在本地存储一个状态列表，保存着所有接收到的信息（含有时间戳），在此基础上，每个参与者都可以构造出一个有向区块图，在经过 blockDAG 协议，每个有向图都是任意的。（？）

为了时间方面的考虑，认为一个区块就是状态中的一条信息，每个区块都有唯一标记哈希（不冲突的），将区块的内容进行哈希，区块的内容也包括了所指向所有区块的标记，被协议加密转换过的交易内容。

#### 2.2.1 有效性

和区块链一样，定义了一个验证函数来验证一个区块是否有效：给定状态，函数将标记图中的区块是否是有效的。

将验证函数分成了两种类型的检验（需要同时满足才能认为是有效的）：

- 语法有效性：仅能通过区块的内容和该区块的视野范围（该区块能触达的区块子图）来计算得出
- 上下文有效性：所有非语法的内容

有向无环区块图的验证函数允许有效区块的视野中有无效的区块，这在现在的区块链协议中不被允许。**我们定义有效的无环图是有效区块组成的无环图。**（注意这样的子图可能不被相连）

#### 2.2.2 区块的顺序

和链式结构不同，一个 DAG 不能保证唯一的一个拓扑排序来指明区块产生的顺序。所以在 blockDAG 协议中额外增加了全局区块唯一顺序的定义（对于一对区块 A B ，若 A < B ，则在有向无环图中不会出现一条 A 到 B 的边，这里比较的应该是时间戳）。

#### 2.2.3 安全性

- 一致性：绝大部分情况下，任意一个时间点下，两个参与者的有效 DAG 不同之处仅仅在于最近的 T 个区块。
- 自一致性：绝大部分情况下，两个时间戳下 r < s ，同一个参与者的有效 DAG 不同之处在于最近的 T 个区块。
- g - 链生长（生存性）：绝大部分情况下，任意一个时间点下，在最近 g 轮执行后至少有 T 个区块在有效 DAG 中被创建了。g 被称为链生长。
- μ - 链质量（公平性）：绝大部分情况下，对于参与者所拥有的任意 T 个连续区块，“由其贡献的”比率至少为 μ 。

### 2.3 Weak Common Coins?

弱普通硬币（ weak common coin ）的 p~coin~ ≤ 0.5 （表示投出正面的概率），它是一个协议，满足以下条件：

- 所有参与者有相同输出且为 0 的概率至少是 p~coin~
- 所有参与者有相同输出且为 1 的概率至少是 p~coin~
- 协议开始之前，竞争者能无法猜出参与者的输出值的概率大于 1 - p~coin~

#### 2.3.1 基于工作证明机制实现弱普通硬币

我们可以用任何的工作量证明机制来实现。区块的产生可以抽象成一个产生速率与计算能力成比例泊松过程。

假设在一个长度为 T 的区间内，区块以速率 λ 的泊松过程生成，网络传播延时 δ。开始时间为 t ，协议如下：

1. 等待到 t + T 时刻， S~p~ 为在区间 [t, t + T ] 内接收到的有效的“新鲜”区块（确保是最新生成的）集合
2. 对 S~p~ 内的区块按照哈希值来排序，参与者输出排序后最小区块的 LSB （最低有效位？字节？）

引理 3.1. 给出了弱普通硬币的结果参数。

**引理 3.1. 如果对手产生的区块速率最多为 qλ ，那么对于每一个常数 c > 1 ，协议产生的弱普通硬币的参数 $p_{coin} \ge c^{-2} \cdot \frac{1-q}{2} \cdot \frac{T-2δ}{T+2δ} - \mathrm{neg}(T)$**

### 2.4 模块化（乌龟）协议

#### 2.4.1 概览

高阶结构结合了“乌龟”协议和一个任意的“野兔”协议。

无论野兔协议的属性如何，长期的 "乌龟 "协议都能保证一致性。对于每一个区块 X ，在野兔协议结束时，各方对其有效性达成一致，乌龟协议将确保所有各方将继续达成一致（并且在未来不会改变）。

1. 如果野兔协议是无竞争的，那么组合协议也是无竞争的。
2. 如果野兔协议保证在所有区块上以概率 p 达成一致，则组合协议将保证在野兔协议结束时以概率能力 p - ε（对于一些可忽略的 ε ）达成不可逆的共识。

乌龟协议具有这样的特性，即一个节点对其视野（ DAG 子图）中任何区块的有效性的判断只取决于视野本身（而不是额外的私有上下文）。因此，给定节点的视图，我们可以 "模拟 "它的计算，重建它对任何区块的判断。为了实现这一点，当对一个区块进行挖掘时，区块的内容将包括节点视野中现有的边无法到达的其他块的“视图”的边（即通往区块 DAG 的 "头 "的边）。

**层**

乌龟协议定义的有向无环图用“层”将区块划分到集合中，“层”是被连续数字记录的，层号是被记录在区块内容中的（即在工作量证明中，层号也是区块名字（哈希）的一部分）。同时要求每个区块维护这个层号记数，算是一个弱共识，去对这个层号做签名。有这层弱共识之后，如果有一个参与者在 t 时刻增加了层号计数器，那么其他的参与者会在 t + δ 时刻（根据第一个参与者的本地时间）也增加同样的值。

注意：触发层计数的事件可以是简单的时间流逝，但也可以取决于每一方的判断（因为我们假设网络中的延迟是 δ 约束的，这仍然会保证弱共识）。在我们的案例中，只要节点能够看到当前层中足够多的语法有效块，层计数器就会递增。

**区块权重**

区块的权重是指生成一个相同难度的区块所需的预期工作量（例如，哈希计算的次数）。为了计算一组区块的 "权重"，我们将集合中每个区块的权重相加。也就是说，如果第 i 层的区块生成阈值为 p ，那么第 i 层每一个区块的权重正好为 1 / p 。

#### 2.4.2 野兔协议的要求

由于乌龟共识机制会继承野兔共识机制的部分特性，所以对野兔协议要做一些要求。为了简单起见，我们将假设野兔协议使用相同的层和层计数器的概念。我们对野兔协议有两个主要的要求：

- **防止预生成块：**为了保证收敛性，我们需要对对手可以 "预生成 "的语法有效区块（即层号在未来的区块）的数量做个边界。乌龟协议是从野兔协议中继承了语法有效性规则，所以这些规则必须确保该边界。为了简单起见，在本文中，我们假设所有的野兔协议都需要一个**最小出度规则**：只有当第 i 层的块在其视野中（在第 i - 1 有效层）至少有 T~min~ 个语法有效块时，它们才是语法有效的。
- **有限的 [t, s] 一致性：**理想情况我们希望每个区块都声明在第 i 层中，层计数器在区间[i+t，i+s]的所有诚实节点都对 X 的有效性达成共识，并且这个共识在区间[starti+t,starti+s+1)内不会发生变化。

#### 2.4.3 乌龟协议介绍

让 Π 成为一个输出区间为[t，s]的限定兔子协议。为了构造相应的乌龟协议，我们需要修改 Π 的验证函数和图的结构。让 i 为层计数器的当前值。

- 增加视图和投票边：除了 Π 指定的边缘外，每个由诚实玩家用 DAG G 生成的块现在将包括特殊边缘。

- 添加硬币位：每个块都会在其头中添加一个硬币。币的值由弱共币协议决定，该协议从时间 starti + δ 开始，如果币为 1，则币位设为 1，否则为 0。

- 增加 "投币前 "位：该位表示区块是否在币协议结束前生成（在币位重要的情况下，该位用于 "弃权 "投票）。

- 增加 "早期块 "位：每一个区块都会在其头中增加一个位，用于指定该区块是否是在层开始后不到 δ 时间内生成的。(这是在上一层的晚块可能会产生差异的情况下，用来弃权的。)

- "区块投票"：对于 i′<i-s 层中的每一个区块 A，A 的有效性将通过以下方式确定： \* "区块投票"。一个简单的 "选举"。每一个语法上有效的区块 Y 都声称自己在 i′+1，......。, i−1 被赋予了 "投票权"，在集合{-1，0，1}中，只要在时间 starti+δ 之前收到 Y。 块。如果 A 的加权票数为正数，A 将被视为有效，其中我们使用的是 的区块权重，由其 PoW 得出。确定块 X′的算法。 投票是递归的。考虑层 j > i 中的一个块 X 。基本的投票规则取决于 X 和 A 之间的距离（以层为单位）。

  - 如果 j<i′+t，那么 X 投票为 0（它对 A 是中立的，因为它是在野兔协议保证对 A 达成共识之前产生的）。

  - 如果 j∈{i′+t，...。，i′+s}，则如果 X 对 A 有投票边缘，则 X 投票为 1，如果没有，则为-1。
  - 否则(j>i′+s)，考虑 X 视图中的所有区块，并将其加权票数相加，如果相加为正，X 投 1 票，否则-1 票。

为了保证收敛性，即使野兔协议无法在诚实节点之间达成共识，我们也会在任何一个方向没有明显多数时，加入随机投票规则。

- 如果 j > i′ +s，并且 X 视图中的区块的投票加权和在[-θ，θ]范围内，如果硬币位被设置为 1，X 投票为 1，否则为-1（除非 "投币前 "位被设置为 1，在这种情况下，它投票为 0）。

#### 2.4.4 协议的参数

Meshcash 协议有几个可调整的参数，这些参数是全局设置的，一旦协议启动，这些参数就会保持固定：

1. T~min~：一层中最小的块数。数目越大，协议的鲁棒性越高，矿工的奖励间隔越短，但代价是增加了通信开销。
2. l: 层间的平均长度 通过根据对总哈希率的估计来调整难度参数（类似于比特币的难度调整机制），使之保持大致不变。
3. δ: 诚实节点之间网络传播时间/本地时钟差的综合约束。如果任何一个诚实节点根据其本地时钟在时间 t 看到一个块，那么所有诚实节点都保证根据自己的本地时钟在时间 t+δ 前收到该块。(注意，实际的网络传播延迟是不可调的，但我们使用的边界是可以调的)。
4. t~coin~: 对执行弱币协议所需时间的约束（以 δ 的倍数为单位）。
5. θ: 使用随机化区块投票协议的阈值。如果一个区块的投票余地（票数之和）小于 θ（绝对值），节点将根据弱币的输出进行投票（而不是使用多数票）。更大的 θ 可以保证从任意初始条件下更快的收敛，但会使对抗者更容易使诚实区块失效（如果诚实区块的余量小于 θ，则可能通过抛币失效）。

#### 2.4.5 协议中的一些概念

**块的语法有效性：**块的语法有效性可以纯粹根据块的可见网格来决定（也就是说，它不取决于 "上下文"，比如它被接收的时间或同层或未来层的其他块）。一个块在第 i 层中的语法有效性有几个条件。

1. 它不指向一个语法无效的块。
2. 该区块具有 i 层难度级别的有效工作证明（注意，难度级别是视图的函数）。
3. 其视图至少包含第 i - 1 层中的 T~min~ 语法有效块。
4. 根据区块视图，区块中包含的交易是有效的。

**层的边界：**诚信节点维护一个层计数器，它决定 "当前层 "的序列号。层计数器在接收生成层时初始化为 1。当第 i 层收到至少 Tmin 个语法有效的块时，层计数器递增为 i+1。

第 i 层的诚实开始，表示 starti，是第一个诚实节点将其计数器递增到 i 的时间。

**区块中的交易：**每个区块都包含一个交易列表。然而，与比特币不同的是，同一交易可能会出现在多个区块中；对于考虑交易有效的目的来说，重要的是它是否被包含在一个层中。如果 i 是 L 出现在 A 的视图中至少一个有效区块中的第一层，我们认为一个交易 L 被包含在 i 层中（根据区块 A）。在一个区块中可以包含的交易数量有一个固定的上限。这个上限可以很容易地根据系统中的交易发布率按比例调整，并且可以发放奖金。）。每个矿工根据协议 1 选择要列入区块的交易。

**冲突的交易和有效性：**各区块之间不会因为其中包含的交易而发生冲突。但是，交易本身可能会发生冲突（例如，双重消费）。如果在同一层中包含了两个冲突的交易，则第一个交易（根据区块维护的一个总排序）被认为是有效的，第二个交易无效。

**分布式的奖励：**我们强调，分配区块奖励的系统是完全独立于 Meshcash 的安全属性的。特别的，我们可以选择任何一种方法来分配奖励，在保证 Meshcash 的激励相容性的同时，保持无竞赛属性。

### 2.5 乌龟协议的安全证明机制

#### 2.5.1 不可逆性

在一个高层次上，我们可以将乌龟协议看作是一个投票过程：每一个新的区块都会对之前所有的区块进行 "投票 "支持或反对。乌龟协议的不可逆转性源于这样一个事实：一旦达成共识，所有诚实的用户都会向同一个方向投票；这导致投票的余地（正票和负票之间的差异）随着时间的推移而线性增加。与比特币竞赛分析类似，对手只能通过产生足够的票数来推翻当前的共识来逆转历史。然而，由于对手产生区块的速度低于诚实的各方，因此可以做到这一点的概率随着时间的推移呈指数级下降。

这里的主要问题是，对手可能会保留一些未公布的区块的 "储备"，然后在晚些时候公布这些区块，从而以较大的余地来推翻看起来像是共识的东西。然而，为了扭转诚实用户关于区块 A 的共识，对手的储备必须包含 "未来的 "区块（其层 id 大于区块 A）--因为只有未来的区块才有关于 A 的 "投票权".我们通过限制对手保留大量 "未来的 "区块储备的能力来证明这种情况不可能发生。在推论 4.10 中，我们表明，无论初始条件如何，都会有一层对手的未来储备达到稳定状态（见定义 4.7）。此外，我们利用以压倒性的概率没有一个层是 "太长 "的这一事实来证明，一旦进入稳态，对手离开稳态的概率可以忽略不计；因为为了产生足够的 "未来 "区块，对手需要一个长的层-间隔。

#### 2.5.2 纯乌龟共识机制

证明的难点在于，即使在主动攻击下，也要证明共识总是（最终）会实现。直观地讲，保证共识的难度在于对手 "玩弄 "网络延迟的能力。通过在一层的 "边缘 "附近发送区块，一些诚实的一方会认为该区块有效，而另一些则不会。投票方案在这种情况下没有帮助，因为诚实的各方现在对投票本身有不同意见（每一票都是一个块）。使分析进一步复杂化的是，对手可以生成和维持一个有效区块的 "储备"（用于当前或未来的层），对手可以战略性地使用这些区块，在诚实的矿工之间造成对层的内容的分歧。

对于任何初始储备的区块（这里我们不关心它们是在未来还是在过去），乌龟协议最终会达成共识。我们通过对对手策略的案例分析，说明对手为了不让诚实的双方达成一致，必须 "花掉 "自己的储备。由于对手产生新区块的能力是有限的，所以要么诚实的双方将达成共识，要么对手将耗尽其储备（在这种情况下，诚实的双方也将达成共识）。

#### 2.5.3 野兔与乌龟共识机制

我们对对手预生成区块能力的约束（即对未来储备的约束）使我们能够证明，一旦我们达到未来储备的稳定状态，任何保证有限一致性的野兔协议与乌龟协议相结合，都能保证一致性和未来的自一致性。这里的想法是直接的，一旦我们在野兔协议中达成共识，诚实的各方都会向同一个方向投票。

#### 2.5.4 无竞争性

为了证明诚实生成的区块总是在共识中，我们需要降低每层中诚实区块的数量限制（因为诚实区块被 "保证 "投给其他诚实区块）。当对手处于未来储备稳定状态时，我们可以做到这一点，通过证明任何一层都不会太短（因为对手只能通过从其未来储备中 "倾倒 "区块来缩短一层），这意味着诚实方有足够的时间在每一层中生成区块。

### 2.6 野兔协议

我们提出了几种不同的野兔协议。第一个协议几乎是微不足道的，但只有当所有参与者都是诚实的时候，才能保证共识。其他的协议比较复杂，使用一个链外异步拜占庭协议（ABA）来实现更稳健的共识，即使在恶意攻击下也是如此。

#### 2.6.1 基于拜占庭协议的野兔机制

在这里我们主要介绍一下基于拜占庭协议的野兔机制。

基于 ABA 的野兔协议背后的基本思想是利用层中发布的区块来选择一个委员会，然后委员会将运行一个链外的 "传统 "拜占庭协议，以实现对层中每个区块有效性的共识。链外协议可以使用直接链接来执行，所以可以相当快；在协议结束时，委员会将附加数字签名（使用其发布的区块中提供的公钥）来证明每个区块的有效性。现在的上下文有效性规则是 "一个声称在第 i 层的区块 A 如果有第 i 层委员会大多数成员的有效签名，那么它就是有效的"。

在使用这种范式时，有两个主要的困难需要克服：第一个是我们没有关于委员会成员的共识；标准的 ABA 协议假设有关于参与者的协议。我们通过使用无身份的 ABA 协议和对参与者总数的约束来解决这个问题。每一方都会与它认可的委员会成员进行交互，并将其他任何成员视为有问题。ABA 协议的特性保证了只要诚实方的数量是最大参与者数量的 2/3，安全性就仍然成立。

第二个问题是 ABA 协议使用了一个 "弱随机币"：这通常是通过一个需要可信设置的密码协议来实现的，而我们没有这个协议。然而，有一些构造是不需要设置的。另外，我们可以使用区块链本身来实现弱随机币（不幸的是，我们的币的实现有一个每次翻币的最小时间，所以 ABA 协议的每一轮也有一个最小时间。但是，我们选择的 ABA 协议需要的轮次预期非常少，所以在高概率的情况下，总时间仍然会小于一层区间。

# script

与区块链共识机制的区别

区块链：

- 链规则：
  - 每个区块都是有效的 pow
  - 只有最长链上的区块是有效的
    - 可任意打破最长链
    - 矿工竞争成为最长链的一部分
  - 每个交易只能出现在一个区块上
    - 不能冲突
- 交易的顺序：

  - Tx1 < Tx2 当且仅当（ iff ）：
    - Tx1 出现在更前面的区块中
    - 或者在同一个区块里， Tx1 出现在前
  - 和区块顺序一致

- 奖励：
  - 区块奖励
    - 每个有效的区块
    - 每个区块都一样
    - 和交易无关
  - 交易费用
    - 支付给包含这些交易的区块
    - 用户支付挖矿
    - 和区块奖励相比微乎其微
- 吞吐量差
  - 区块生成率低
  - 每个区块大小限制（网络传播延迟）

Meshcash：

- 无限制的区块率
- 无竞争的（有什么好处？）
  - 诚信参与者的奖励不会因其他人的操作而减少
  - 游戏理论

为什么是 mesh ？为了实现无竞争，因为不会只取一个作为成功的区块

mesh 就是一个层级 DAG

- 无竞争
- 整个层的区块可以同时被挖矿（提升吞吐量）
  - 扩展层 -> 无限制的挖矿率
- 之前的 DAG 实现没有
  - 安全证明机制
  - 没有全局的共识
  - ...

实现

- 每一层都有层号
  - 指向前一层的
  - 指向入度为 0 的
- 什么时候开始下一层？
  - 如果发现当前层已经有 T~min~ 个区块，就增加 1 个层号
  - 不用时钟同步

检查有效性

- 语法有效性：
  - 区块自己的定义
  - PoW 是否合法
  - 指向的每个区块是否是语法有效的（递归的去检查）
  - 指向的前一层至少有 T~min~ 个区块
- 上下文有效性：（为什么？因为语法有效性不够，需要知道其他区块是合法的）
  - 比特币：最长的链
  - 乌龟协议：验证较远的层区块历史（第 i - t 层之前的所有）
  - 野兔协议：验证较近的层区块（第 i - t 到 i - s 的层）（可以是各种协议，插件）
  - 最新的层：需要等待（第 i 到 i - s 层），此时由于区块的生成速度没有限制，很快就会新增层数，这些等待的层很快就被野兔协议给验证了

乌龟协议：

- 核心：对有效性进行投票
- 条件：
  - 区块有足够的信息来重建矿工的投票
    - 生成的时间
    - 视野内所有的前置区块
- 修改挖矿算法：
  - 加入“投票边”到最近的区块

slow but sure

fast but unreliable

#### 开场 P1 P2：

##### P1

大家好，我是李经纬，今天介绍 Meshcash 区块链框架，是在 2017 年提出的一套共识机制协议，能够解决比特币区块链一些痛点。其中采用了一对乌龟、野兔共识机制。

##### P2

那么我主要从四个板块介绍这个共识机制。

#### 介绍 Meshcash 特点，设计目标 P3：

简单来说，学术界分析比特币的最初设计发现了其中的三个痛点：网络处理交易的吞吐量差、这也间接导致区块生产率低（需要等待 10 分钟挖出一个新区块），同时每个区块容量也有限制。

而 Meshcash 框架解决了这些问题，解放了区块的生产速率，同时，相较于比特币只能由一个竞选者成为挖矿成功的人，在 Meshcash 中是没有竞争的概念的，每个成功挖到矿的人都会得到奖励。

#### 如何实现 P4 P5 P6

##### P4

那么我们先看一下是如何实现这些特点的，和比特币的链式结构不同， mc 采用了层级的有向无环图作为网络结构，每个挖到矿的矿工都能将自己的区块添加到新的一层中，这样一来就实现了“无竞争”，同时整个层的区块可以并发挖矿，层的宽度也能扩展。这样可以提升吞吐量

之前也有相关工作使用了 DAG ，但是 Meshcash 提供了安全证明机制，全局的共识机制等

##### P5

实现这些功能首先在每个区块中要保存所属层级的层号，同时保存前一层所有区块的哈希值，也就指向前一层的所有区块，同时也需要指向入度为 0 的区块，（点鼠标）在比特币中是每间隔 10 分钟在链上添加一个新区块，在层级的有向无环图中，如果发现当前层已经有 Tmin 个区块的时候，层数计数器就会增加一个层号。这个 Tmin 是框架的一个参数。

##### P6

区块有效性的检查分为两个种类：

第一个是语法有效性，会检查区块自己的定义，工作量证明是否合法，同时递归的去检查每个区块指向的区块是否是语法有效的，并且指向的前一层至少有 Tmin 个区块。

#### 乌龟野兔协议之间的关系 P7

第二个是上下文有效性的检查：由于语法有效性不足以认为整个网络是合法的，比如区块链是认为最长的链才是合法的，这就是上下文有效性，验证区块之间的连续性。

因此采用了乌龟和野兔协议对整个历史层级进行验证。

乌龟协议验证较久远的层区块有效性**_（动画）_**比较复杂，耗时多，但是可靠

野兔协议验证较近的层区块有效性**_（动画）_**，这个协议是可以自行选择的，效率高，但是有出错的可能，但最终会有乌龟共识机制做保障。

那么最前面的层就需要等待一会被验证了，但是由于前面说到区块生产的速度没有限制，层数增加很快，很快就能被野兔协议验证。

#### 乌龟协议算法流程 P8 P9

##### P8

那我们来看一下乌龟协议算法的简单原理，他的核心思想就是让所有历史区块对目标区块的有效性进行投票

区块所要提供一些信息，比如被创建的时间，可以触达的前置区块子图等，来重构投票信息，以便于之后经历的每一轮验证

同时我们需要加入每个区块的投票边，就是增加一条边，指向之前已经被验证成功的区块

##### P9

我们以橙色的第四层向橙色的第一层区块投票为例**_（点鼠标）_**保留可触达的子图

利用子图内所有区块到目标区块的距离进行投票

根据投票规则，离得最近的层还无法确认，投 0**_（点鼠标）_**表示中立，对目标区块不产生影响
距离较近的层，存在投票边，这里我用的是虚线，就投 1，不存在的投 -1**_（点鼠标）_**

**_（点鼠标）_**

**_（点鼠标）_**

最终将投票求和，得到的数位正就说明目标区块是合法有效的

#### 小结 P10

那么以上就是对 meshcash 框架结构实现以及其共识机制原理的简单介绍，还有很多细节和参数在原论文中会详细介绍。

小结一下 meshcash 框架，他结合了乌龟野兔机制，能够快速的完成新区块的共识验证，也能保障全局的有效性，在提升区块产出速率的同时带来了无竞争的特性。

我的演讲结束了，谢谢大家

from https://www.youtube.com/watch?v=t4Emf8UmlBw
